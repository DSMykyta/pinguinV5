<!DOCTYPE html>
<html lang="uk">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Локальна база даних</title>
    <link rel="stylesheet" href="styles/main.css">

    <script async defer src="https://apis.google.com/js/api.js"></script>
    <script async defer src="https://accounts.google.com/gsi/client"></script>
</head>

<body>

    <div class="main-content">

        <header class="header">

            <div class="connected-button-group-square tabs-head" role="group" aria-label="Таби">

                <button class="segment tab-button active" aria-label="Категорії" data-tab="categories">
                    <div class="state-layer">
                        Категорії</span>
                    </div>
                </button>

                <button class="segment tab-button" aria-label="Характеристики" data-tab="characteristics">
                    <div class="state-layer">
                        <span class="label">Характеристики</span>
                    </div>
                </button>

                <button class="segment tab-button" aria-label="Опції" data-tab="options">
                    <div class="state-layer">
                        <span class="label">Опції</span>
                    </div>
                </button>

            </div>

            <div class="search-bar">
                <div class="state-layer">
                    <div class="leading-icon"></div>

                    <div class="content">
                        <input type="search" id="searchInput" class="search-input" placeholder="Пошук...">
                    </div>

                    <div class="trailing-elements">
                        <button class="trailing-icon" aria-label="Search">
                            <svg xmlns="http://www.w3.org/2000/svg" height="24px" viewBox="0 0 24 24" width="24px"
                                fill="#49454F">
                                <path d="M0 0h24v24H0z" fill="none" />
                                <path
                                    d="M15.5 14h-.79l-.28-.27C15.41 12.59 16 11.11 16 9.5 16 5.91 13.09 3 9.5 3S3 5.91 3 9.5 5.91 16 9.5 16c1.61 0 3.09-.59 4.23-1.57l.27.28v.79l5 4.99L20.49 19l-4.99-5zm-6 0C7.01 14 5 11.99 5 9.5S7.01 5 9.5 5 14 7.01 14 9.5 11.99 14 9.5 14z" />
                            </svg>
                        </button>
                        <div class="trailing-icon-2"></div>
                    </div>
                </div>
            </div>


            <div class="xr-toolbar">
                <div class="toolbar tabs-head">

                    <a href="https://docs.google.com/spreadsheets/d/1iFOCQUbisLprSfIkfCar3Oc5f8JW12kA0dpHzjEXSsk/edit"
                        target="_blank" rel="noopener noreferrer" class="toolbar-button" aria-label="Відкрити таблицю"
                        title="Відкрити Google Sheets у новій вкладці">
                        <div class="content">
                            <div class="state-layer">
                                <svg class="icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"
                                    fill="currentColor">
                                    <path
                                        d="M19 19H5V5h7V3H5c-1.11 0-2 .9-2 2v14c0 1.1.89 2 2 2h14c1.1 0 2-.9 2-2v-7h-2v7zM14 3v2h3.59l-9.83 9.83 1.41 1.41L19 6.41V10h2V3h-7z">
                                    </path>
                                </svg>
                            </div>
                        </div>
                    </a>

                    <button id="refreshDataBtn" class="toolbar-button" aria-label="Оновити дані"
                        title="Оновити дані з Google Sheets">
                        <div class="content">
                            <div class="state-layer">
                                <svg class="icon" viewBox="0 0 24 24" xmlns="http://www.w3.org/2000/svg"
                                    fill="currentColor">
                                    <path
                                        d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z" />
                                </svg>
                            </div>
                        </div>
                    </button>


                </div>

                <div class="header-controls">
                    <button id="authorize_button" class="fab" aria-label="Авторизуватися" style="display: none;">
                        <div class="state-layer">
                            Авторизуватися
                        </div>
                    </button>

                    <button id="signout_button" class="fab" aria-label="Вийти" style="display: none;">
                        <div class="state-layer">
                            Вийти
                        </div>
                    </button>
                </div>
            </div>

        </header>

        <main class="tabs-container">
            <div class="tab-content active" id="categories">
                <div class="tab-content-header">
                    <h2>Категорії <span class="tulip"><span id="categories-counter-page">0</span> з <span
                                id="categories-counter-all">0</span></span></h2>
                    <button class="btn-secondary btn-add">Додати</button>
                </div>
                <div class="pseudo-table-container">
                    <div class="pseudo-table">
                        <div class="pseudo-table-header">
                            <div class="pseudo-table-cell cell-actions header-actions-cell">
                                <input type="checkbox" id="selectAllCategories" class="header-select-all"
                                    aria-label="Вибрати все видиме"><span>Дії</span>
                                <span></span>
                            </div>
                            <div class="pseudo-table-cell cell-id sortable-header" data-sort-key="local_id">
                                <span>ID</span>
                                <span class="sort-indicator"></span>
                            </div>

                            <div class="pseudo-table-cell cell-level sortable-header" data-sort-key="level">
                                <span>LVL</span>
                                <span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell cell-main-name sortable-header" data-sort-key="name_uk">
                                <span>Основна назва</span>
                                <span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="etalon_name">
                                <span>Etalon</span>
                                <span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="rztk_name">
                                <span>Rozetka</span>
                                <span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="epicenter_name">
                                <span>Epicenter</span>
                                <span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="allo_name">
                                <span>Allo</span>
                                <span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="fua_name">
                                <span>F.ua</span>
                                <span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="maudau_name">
                                <span>Maudau</span>
                                <span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell cell-count sortable-header" data-sort-key="charCount">
                                <span>CHAR</span>
                                <span class="sort-indicator"></span>
                            </div>
                        </div>
                        <div class="pseudo-table-body">
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="characteristics">
                <div class="tab-content-header">
                    <h2>Характеристики <span class="tulip"><span id="characteristics-counter-page">0</span> з <span
                                id="characteristics-counter-all">0</span></span></h2>
                    <button class="btn-secondary btn-add">Додати</button>
                </div>
                <div class="pseudo-table-container">
                    <div class="pseudo-table">
                        <div class="pseudo-table-header">

                            <div class="pseudo-table-cell cell-actions header-actions-cell">
                                <input type="checkbox" id="selectAllCharacteristics" class="header-select-all">
                                <span>Дії</span>
                            </div>

                            <div class="pseudo-table-cell cell-id sortable-header" data-sort-key="local_id">
                                <span>ID</span>
                                <span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell cell-linked-cats sortable-header"
                                data-sort-key="linkedCategoryNames">
                                <span>Категорії</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell cell-main-name sortable-header" data-sort-key="name_uk">
                                <span>Основна назва</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="etalon_name">
                                <span>Etalon</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="rztk_name">
                                <span>Rozetka</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell cell-bool sortable-header" data-sort-key="is_global">
                                <span>GLO</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell cell-count sortable-header" data-sort-key="optionCount">
                                <span>OPT</span><span class="sort-indicator"></span>
                            </div>
                        </div>
                        <div class="pseudo-table-body">
                        </div>
                    </div>
                </div>
            </div>

            <div class="tab-content" id="options">
                <div class="tab-content-header">
                    <h2>Опції <span class="tulip"><span id="options-counter-page">0</span> з <span
                                id="options-counter-all">0</span></span></h2>
                    <button class="btn-secondary btn-add">Додати</button>
                </div>
                <div class="pseudo-table-container">
                    <div class="pseudo-table">
                        <div class="pseudo-table-header">
                            <div class="pseudo-table-cell cell-actions header-actions-cell">
                                <input type="checkbox" id="selectAllOptions" class="header-select-all"><span>Дії</span>
                            </div>
                            <div class="pseudo-table-cell cell-id sortable-header" data-sort-key="local_id">
                                <span>ID</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="linkedCategoryNames">
                                <span>Категорія</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="parentCharacteristicName">
                                <span>Характеристика</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell cell-main-name sortable-header" data-sort-key="name_uk">
                                <span>Назва</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="etalon_name">
                                <span>Etalon</span><span class="sort-indicator"></span>
                            </div>
                            <div class="pseudo-table-cell sortable-header" data-sort-key="rztk_name">
                                <span>Rozetka</span><span class="sort-indicator"></span>
                            </div>                                                        
                        </div>

                        <div class="pseudo-table-body"></div>
                    </div>
                </div>
            </div>

        </main>

        <footer class="footer">
            <div class="connected-button-group-round" role="group">
                <button id="importBtn" class="segment" aria-label="Імпорт">
                    <div class="state-layer"><span class="label">Імпорт</span></div>
                </button>
                <button id="exportBtn" class="segment" aria-label="Експорт">
                    <div class="state-layer"><span class="label">Експорт</span></div>
                </button>
                <button id="deleteBtn" class="segment btn-delete" aria-label="Видалити" disabled>
                    <div class="state-layer"><span class="label">Видалити</span></div>
                </button>
                <button id="mergeBtn" class="segment" aria-label="Співставити" disabled>
                    <div class="state-layer"><span class="label">Співставити</span></div>
                </button>
            </div>

            <div class="pagination-container">
                <div id="pagination-nav-container" class="pagination-nav"></div>

                <div class="page-size-selector" id="page-size-selector">
                    <button class="page-size-trigger" aria-label="Кількість на сторінці">
                        <span id="page-size-label">10</span>
                    </button>
                    <div class="page-size-menu">
                        <button class="page-size-option" data-page-size="10">10</button>
                        <button class="page-size-option" data-page-size="25">25</button>
                        <button class="page-size-option" data-page-size="50">50</button>
                        <button class="page-size-option" data-page-size="100">100</button>
                        <button class="page-size-option" data-page-size="999999">Всі</button>
                    </div>
                </div>
            </div>
        </footer>

    </div>

    <div id="modal-placeholder"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/xlsx/0.18.5/xlsx.full.min.js"></script>
    <script type="module" src="scripts/main.js"></script>
</body>

</html>
<div class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <div class="modal-title-container">
                <h2 id="modal-title">Створити категорію</h2>
            </div>
            <div class="header-actions">
                <div class="connected-button-group-square" role="group">

                    <button id="modal-back-btn" class="segment" style="display: none;" aria-label="Назад">
                        <div class="state-layer">
                            <span class="label">Назад</span>
                        </div>
                    </button>

                    <button id="show-children-btn" class="segment" style="display: none;"
                        aria-label="Дочірні категорії">
                        <div class="state-layer">
                            <span class="label">Дочірні категорії</span>
                        </div>
                    </button>

                    <button id="show-chars-btn" class="segment" style="display: none;"
                        aria-label="Прив'язані характеристики">
                        <div class="state-layer">
                            <span class="label">Прив'язані характеристики</span>
                        </div>
                    </button>

                    <button id="saveCategoryBtn" class="segment" aria-label="Зберегти">
                        <div class="state-layer">
                            <span class="label">Зберегти</span>
                        </div>
                    </button>

                    <button class="segment modal-close-btn">
                        <div class="state-layer">
                            <span class="label">&times;</span>
                        </div>
                    </button>

                </div>
            </div>
        </div>

        <div class="modal-body modal-body--split">
            <div class="form-section scrollable-panel">
                <input type="hidden" id="cat-local_id">

                <fieldset class="form-fieldset">
                    <legend>Основна інформація</legend>
                    <div class="form-grid">
                        <div class="form-group span-5">
                            <label for="cat-parent_local_id">Батьківська категорія</label>
                            <select id="cat-parent_local_id" data-custom-select placeholder="Оберіть категорію...">
                                <option value="">-- Коренева --</option>
                            </select>
                        </div>

                        <div class="form-group">
                            <label>Тип категорії</label>
                            <label class="toggle-switch-segmented">
                                <input type="checkbox" id="cat-category_type" checked>
                                <span class="slider">
                                    <span class="text-off">Групуюча</span>
                                    <span class="text-on">Кінцева</span>
                                </span>
                            </label>
                        </div>
                    </div>
                    
                    <div class="form-group" style="margin-top: 16px;">
                        <label>Назва</label>
                        <div class="form-input-group">
                            <div class="input-with-chip">
                                <input type="text" id="cat-name_uk" placeholder="Назва українською *" required>
                                <span class="input-language-chip">укр</span>
                            </div>
                            <div class="input-with-chip">
                                <input type="text" id="cat-name_ru" placeholder="Назва російською">
                                <span class="input-language-chip">рос</span>
                            </div>
                        </div>
                    </div>
                </fieldset>

                <fieldset class="form-fieldset">
                    <legend>Дані маркетплейсів</legend>
                    <div class="marketplace-grid">
                        <div class="marketplace-header">Платформа</div>
                        <div class="marketplace-header">ID</div>
                        <div class="marketplace-header">Назва</div>

                        <label class="marketplace-name" for="cat-etalon_id">Etalon</label>
                        <input type="text" id="cat-etalon_id" placeholder="ID">
                        <input type="text" id="cat-etalon_name" placeholder="Назва на Etalon">

                        <label class="marketplace-name" for="cat-rztk_id">Rozetka</label>
                        <input type="text" id="cat-rztk_id" placeholder="ID">
                        <input type="text" id="cat-rztk_name" placeholder="Назва на Rozetka">

                        <label class="marketplace-name" for="cat-epicenter_id">Epicenter</label>
                        <input type="text" id="cat-epicenter_id" placeholder="ID">
                        <input type="text" id="cat-epicenter_name" placeholder="Назва на Epicenter">

                        <label class="marketplace-name" for="cat-allo_id">Allo</label>
                        <input type="text" id="cat-allo_id" placeholder="ID">
                        <input type="text" id="cat-allo_name" placeholder="Назва на Allo">

                        <label class="marketplace-name" for="cat-fua_id">F.ua</label>
                        <input type="text" id="cat-fua_id" placeholder="ID">
                        <input type="text" id="cat-fua_name" placeholder="Назва на F.ua">

                        <label class="marketplace-name" for="cat-maudau_id">Maudau</label>
                        <input type="text" id="cat-maudau_id" placeholder="ID">
                        <input type="text" id="cat-maudau_name" placeholder="Назва на Maudau">
                    </div>
                </fieldset>
            </div>

            <div id="children-panel" class="related-section scrollable-panel">
                <div class="related-content-container"></div>
            </div>

            <div id="characteristics-panel" class="related-section scrollable-panel">
                <div class="related-content-container"></div>
            </div>
        </div>
    </div>
</div>
<div class="modal-overlay">
    <div class="modal-content">
        <div class="modal-header">
            <h2 id="modal-title">Створити характеристику</h2>
            <div class="header-actions">
                <div class="connected-button-group-square" role="group">
                    <button id="show-options-btn" class="segment" style="display: none;" aria-label="Опції">
                        <div class="state-layer"><span class="label">Опції</span></div>
                    </button>
                    <button id="saveCharacteristicBtn" class="segment" aria-label="Зберегти">
                        <div class="state-layer"><span class="label">Зберегти</span></div>
                    </button>
                    <button class="segment modal-close-btn">
                        <div class="state-layer"><span class="label">&times;</span></div>
                    </button>
                </div>
            </div>
        </div>

        <div class="modal-body modal-body--split">
            <div class="form-section scrollable-panel">
                <input type="hidden" id="char-local_id">

                <fieldset class="form-fieldset">
                    <legend>Основна інформація</legend>
                    <div class="form-grid">
                        <div class="form-group span-5">
                            <label for="char-category_local_ids">Прив'язка до категорій</label>
                            <select id="char-category_local_ids" multiple data-custom-select placeholder="Пошук..."></select>
                        </div>
                        <div class="form-group">
                            <label>Наскрізний</label>
                            <label class="toggle-switch-segmented">
                                <input type="checkbox" id="char-is_global">
                                <span class="slider"><span class="text-off">Ні</span><span class="text-on">Так</span></span>
                            </label>
                        </div>
                    </div>
                    <div class="form-grid-3">
                        <div class="form-group">
                            <label for="char-param_type">Тип параметра</label>
                            <select id="char-param_type" data-custom-select>
                                <option value="ComboBox">ComboBox</option>
                                <option value="List">List</option>
                                <option value="ListValues">ListValues</option>
                                <option value="Decimal">Decimal</option>
                                <option value="Integer">Integer</option>
                                <option value="TextInput">TextInput</option>
                                <option value="MultiText">MultiText</option>
                                <option value="TextArea">TextArea</option>
                            </select>
                        </div>
                        <div class="form-group">
                            <label for="char-unit">Одиниця вимірювання</label>
                            <input type="text" id="char-unit">
                        </div>
                        <div class="form-group">
                            <label>Тип фільтра</label>
                            <label class="toggle-switch-segmented">
                                <input type="checkbox" id="char-filter_type">
                                <span class="slider"><span class="text-off">Disable</span><span class="text-on">Main</span></span>
                            </label>
                        </div>
                    </div>
                    <div class="form-responsive-pair">
                        <div class="form-group">
                            <label>Назва</label>
                            <div class="form-input-group">
                                <div class="input-with-chip">
                                    <input type="text" id="char-name_uk" required placeholder="Назва українською *">
                                    <span class="input-language-chip">укр</span>
                                </div>
                                <div class="input-with-chip">
                                    <input type="text" id="char-name_ru" placeholder="Назва російською">
                                    <span class="input-language-chip">рос</span>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                             <div class="form-group">
                                <label for="char-triggering_option_id">Належить до опції</label>
                                <select id="char-triggering_option_id" data-custom-select placeholder="Оберіть..."></select>
                            </div>
                             <div class="form-group">
                                <!-- <label for="char-notes">Примітка</label>-->
                                <textarea id="char-notes" rows="1" placeholder="Примітка..."></textarea>
                            </div>
                        </div>
                    </div>
                </fieldset>

                <fieldset class="form-fieldset">
                    <legend>Дані маркетплейсів</legend>
                    
                    <div class="form-fieldset">
                        <h4 class="marketplace-heading">Etalon</h4>
                        <div class="form-grid">
                            <input type="text" id="char-etalon_id" placeholder="ID на Etalon">
                            <input type="text" id="char-etalon_name" class="form-group span-5" placeholder="Назва на Etalon">
                        </div>
                        <div class="form-grid-3">
                             <div class="form-group">
                                <label>Тип параметра (E)</label>
                                <select id="char-etalon_param_type" data-custom-select>
                                    <option value="Поле для вводу">Поле для вводу</option>
                                    <option value="Вибір одного значення">Вибір одного значення</option>
                                    <option value="Вибір декількох значення">Вибір декількох значення</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Тип фільтра (E)</label>
                                <label class="toggle-switch-segmented">
                                    <input type="checkbox" id="char-etalon_filter_type">
                                    <span class="slider"><span class="text-off">Disable</span><span class="text-on">Main</span></span>
                                </label>
                            </div>
                            <div class="form-group">
                                <label>Одиниця вим. (E)</label>
                                <input type="text" id="char-etalon_unit" placeholder="Одиниця">
                            </div>
                        </div>
                    </div>

                    <div class="form-fieldset">
                        <h4 class="marketplace-heading">Rozetka</h4>
                         <div class="form-grid">
                            <input type="text" id="char-rztk_id" placeholder="ID параметра">
                            <input type="text" id="char-rztk_name" class="form-group span-5" placeholder="Назва параметра">
                        </div>
                        <div class="form-grid-3">
                             <div class="form-group">
                                <label>Тип параметра (R)</label>
                                <select id="char-rztk_param_type" data-custom-select>
                                    <option value="ComboBox">ComboBox</option>
                                    <option value="List">List</option>
                                    <option value="ListValues">ListValues</option>
                                    <option value="Decimal">Decimal</option>
                                    <option value="Integer">Integer</option>
                                    <option value="TextInput">TextInput</option>
                                    <option value="MultiText">MultiText</option>
                                    <option value="TextArea">TextArea</option>
                                </select>
                            </div>
                            <div class="form-group">
                                <label>Тип фільтра (R)</label>
                                <label class="toggle-switch-segmented">
                                    <input type="checkbox" id="char-rztk_filter_type">
                                    <span class="slider"><span class="text-off">Disable</span><span class="text-on">Main</span></span>
                                </label>
                            </div>
                            <div class="form-group">
                                <label>Одиниця вим. (R)</label>
                                <input type="text" id="char-rztk_unit" placeholder="Одиниця">
                            </div>
                        </div>
                    </div>
                </fieldset>
            </div>

            <div id="options-panel" class="related-section scrollable-panel">
                <div class="related-content-container"></div>
            </div>
        </div>
    </div>
</div>
<div class="modal-overlay">
    <div class="modal-content" style="width: auto; height: auto;">
        <div class="modal-header">
            <h2 id="delete-modal-title">Підтвердження видалення</h2>
            <button class="segment modal-close-btn" aria-label="Закрити">
                <div class="state-layer"><span class="label">&times;</span></div>
            </button>
        </div>
        <div class="modal-body scrollable-panel">
            <p id="delete-summary-text"></p>
            <div id="delete-details-container"></div>
        </div>
        <div class="modal-footer">
             <div class="connected-button-group-round" role="group">
                <button id="btn-cancel-delete" class="segment">
                    <div class="state-layer"><span class="label">Скасувати</span></div>
                </button>
                <button id="btn-delete-safe" class="segment" style="display: none;">
                    <div class="state-layer"><span class="label"></span></div>
                </button>
                <button id="btn-delete-cascade" class="segment accent-btn" style="display: none;">
                    <div class="state-layer"><span class="label"></span></div>
                </button>
            </div>
        </div>
    </div>
</div>
<div class="modal-overlay">
    <div class="modal-content" style="max-width: 800px;">
        <div class="modal-header">
            <h2 id="modal-title">Імпорт довідника</h2>
            <button class="segment modal-close-btn" aria-label="Закрити">
                <div class="state-layer"><span class="label">&times;</span></div>
            </button>
        </div>
        <div class="modal-body scrollable-panel">
            <fieldset class="form-fieldset">
                <legend>Налаштування імпорту</legend>
                <div class="form-grid-2">
                    <div class="form-group">
                        <label for="import-marketplace">Маркетплейс</label>
                        <select id="import-marketplace" data-custom-select>
                            <option value="rztk">Rozetka</option>
                            <option value="etalon">Etalon</option>
                            <option value="epicenter">Epicenter</option>
                        </select>
                    </div>
                    <div class="form-group">
                        <label id="import-category-label" for="import-target-category">Прив'язати до категорії</label>
                        <select id="import-target-category" data-custom-select
                            placeholder="Спочатку оберіть маркетплейс"></select>
                    </div>
                </div>
                <div class="form-group" style="margin-top: 16px;">
                    <label>Файл довідника (.xls)</label>
                    <div id="import-drop-area"
                        style="border: 2px dashed var(--color-outline); border-radius: var(--radius-m); padding: 40px; text-align: center; cursor: pointer;">
                        <p>Перетягніть файл сюди або натисніть, щоб вибрати</p>
                        <input type="file" id="import-file-input" accept=".xls" style="display: none;">
                        <p id="import-file-name" style="margin-top: 10px; font-weight: 500;"></p>
                    </div>
                </div>
            </fieldset>

            <fieldset class="form-fieldset">
                <legend>Процес</legend>
                <div class="progress-bar-container" style="margin-bottom: 16px;">
                    <div class="progress-bar-wave"></div>
                    <div id="import-progress-bar" class="progress-bar-fill"></div>
                </div>
                <div id="import-log" style="height: 150px; background-color: var(--color-surface-c-low); border-radius: var(--radius-m); padding: var(--space-m); font-family: monospace; font-size: 12px; overflow-y: auto; white-space: pre-wrap;">Очікування файлу...</div>
                <div id="import-summary" style="margin-top: 16px; font-weight: 500;"></div>
            </fieldset>
        </div>
        <div class="modal-footer">
            <button id="btn-start-import" class="btn-save" disabled>
                <span class="label">Почати імпорт</span>
            </button>
        </div>
    </div>
</div>
<div class="modal-overlay">
    <div class="modal-content" style="max-width: 600px;">
        <div class="modal-header">
            <h2 id="modal-title">Створити опцію</h2>
            <div class="header-actions">
                <div class="connected-button-group-square" role="group">
                    <button id="saveOptionBtn" class="segment" aria-label="Зберегти">
                        <div class="state-layer"><span class="label">Зберегти</span></div>
                    </button>
                    <button class="segment modal-close-btn">
                        <div class="state-layer"><span class="label">&times;</span></div>
                    </button>
                </div>
            </div>
        </div>
        <div class="modal-body scrollable-panel">
            <input type="hidden" id="opt-local_id">
            <fieldset class="form-fieldset">
                <legend>Основна інформація</legend>
                <div class="form-group">
                    <label for="opt-char_local_id">Батьківська характеристика *</label>
                    <select id="opt-char_local_id" data-custom-select placeholder="Оберіть характеристику..."></select>
                </div>
                
                <div class="form-group" style="margin-top: 16px;">
                    <label>Назва</label>
                    <div class="form-input-group">
                        <div class="input-with-chip">
                            <input type="text" id="opt-name_uk" required placeholder="Назва українською *">
                            <span class="input-language-chip">укр</span>
                        </div>
                        <div class="input-with-chip">
                            <input type="text" id="opt-name_ru" placeholder="Назва російською">
                            <span class="input-language-chip">рос</span>
                        </div>
                    </div>
                </div>
            </fieldset>

            <fieldset class="form-fieldset">
                <legend>Дані маркетплейсів</legend>
                <div class="marketplace-grid">
                    <div class="marketplace-header">Платформа</div>
                    <div class="marketplace-header">ID</div>
                    <div class="marketplace-header">Назва</div>

                    <label class="marketplace-name" for="opt-etalon_id">Etalon</label>
                    <input type="text" id="opt-etalon_id" placeholder="ID">
                    <input type="text" id="opt-etalon_name" placeholder="Назва на Etalon">

                    <label class="marketplace-name" for="opt-rztk_id">Rozetka</label>
                    <input type="text" id="opt-rztk_id" placeholder="ID">
                    <input type="text" id="opt-rztk_name" placeholder="Назва на Rozetka">
                </div>
            </fieldset>
        </div>
    </div>
</div>
<div class="panel-header">
    <h3 class="panel-title">{{TITLE}}</h3>
    <div class="panel-controls">
        <div class="panel-search">
            <input type="search" class="side-panel-search" placeholder="Пошук..." data-table-target-id="{{TABLE_ID}}">
        </div>
        <div class="panel-actions">
            <div class="connected-button-group-round" role="group">
                <button class="segment btn-delete" disabled>
                    <div class="state-layer"><span class="label">Видалити</span></div>
                </button>
                <button class="segment" disabled>
                    <div class="state-layer"><span class="label">Об'єднати</span></div>
                </button>
            </div>
        </div>
    </div>
</div>

<div class="pseudo-table side-panel-table" id="{{TABLE_ID}}" data-entity-type="{{ENTITY_TYPE}}">
    <div class="pseudo-table-header">
        <div class="pseudo-table-cell cell-actions header-actions-cell">
            <input type="checkbox" id="{{SELECT_ALL_ID}}" class="header-select-all" aria-label="Вибрати все видиме">
            <span>Дії</span>
        </div>
        {{HEADER_CELLS}}
    </div>
    <div class="pseudo-table-body">
        {{BODY_ROWS}}
    </div>
</div>
<div class="panel-header">
    <h3 class="panel-title">{{TITLE}}</h3>
    <div class="panel-controls">
        <div class="panel-search">
            <input type="search" class="side-panel-search" placeholder="Пошук..." data-table-target-id="{{TABLE_ID}}">
        </div>
        <div class="panel-actions">
            <div class="connected-button-group-round" role="group">
                <button class="segment btn-delete" disabled>
                    <div class="state-layer"><span class="label">Видалити</span></div>
                </button>
                <button class="segment" disabled>
                    <div class="state-layer"><span class="label">Об'єднати</span></div>
                </button>
            </div>
        </div>
    </div>
</div>

<div class="pseudo-table side-panel-table" id="{{TABLE_ID}}" data-entity-type="{{ENTITY_TYPE}}">

    <div class="pseudo-table-header">
        <div class="pseudo-table-cell cell-actions header-actions-cell">
            <input type="checkbox" id="{{SELECT_ALL_ID}}" class="header-select-all" aria-label="Вибрати все видиме">
            <span>Дії</span>
        </div>
        {{HEADER_CELLS}}
    </div>
    <div class="pseudo-table-body">
        {{BODY_ROWS}}
    </div>
</div>
<div class="panel-header">
    <h3 class="panel-title">{{TITLE}}</h3>
    <div class="panel-controls">
        <div class="panel-search">
            <input type="search" class="side-panel-search" placeholder="Пошук..." data-table-target-id="{{TABLE_ID}}">
        </div>
        <div class="panel-actions">
            <div class="connected-button-group-round" role="group">
                <button class="segment btn-delete" disabled>
                    <div class="state-layer"><span class="label">Видалити</span></div>
                </button>
            </div>
        </div>
    </div>
</div>
<div class="pseudo-table side-panel-table" id="{{TABLE_ID}}" data-entity-type="{{ENTITY_TYPE}}">

    <div class="pseudo-table-header">
        <div class="pseudo-table-cell cell-actions header-actions-cell">
            <input type="checkbox" id="{{SELECT_ALL_ID}}" class="header-select-all" aria-label="Вибрати все видиме">
            <span>Дії</span>
        </div>
        {{HEADER_CELLS}}
    </div>
    <div class="pseudo-table-body">
        {{BODY_ROWS}}
    </div>
</div>
// scripts/main.js
import { initAuth } from './api/auth.js';
import { initTabs } from './components/tabs.js';
import { initControls } from './components/controls.js';

import { initTableInteractions, renderActiveTable, clearActiveTable } from './components/table.js';
import { initCustomSelects } from './components/select.js';
import { initSearch } from './features/search.js';
import { initPagination } from './features/pagination.js';
import { initSorting } from './features/sorting.js';
import { initTooltips } from './features/tooltip.js';
import { initSelection } from './actions/selection.js';
import { initDeleteFunctionality } from './actions/delete.js';
import { initModalButtons } from './components/modal_init.js'

/**
 * (НОВА ФУНКЦІЯ) Централізований обробник статусу авторизації.
 */
function handleAuthChange(event) {
    const { isSignedIn } = event.detail;
    if (isSignedIn) {
        // Рендеримо ту таблицю, яка зараз активна
        renderActiveTable();
    } else {
        // Очищуємо таблицю та показуємо повідомлення про необхідність входу
        clearActiveTable();
    }
}

document.addEventListener('DOMContentLoaded', () => {
    console.log("DOM завантажено. Ініціалізуємо компоненти...");
    initTabs();
    initModalButtons();
    initControls();
    initTableInteractions();
    initSearch();
    initAuth();
    initCustomSelects();
    initSelection();
    initDeleteFunctionality();
    initPagination();
    initSorting();
    initTooltips();

    // (НОВЕ) Додаємо слухача подій
    document.addEventListener('authStatusChange', handleAuthChange);
});
// scripts/actions/delete.js (ПОВНА ОНОВЛЕНА ВЕРСІЯ)

import { analyzeCategoriesForDeletion, analyzeCharacteristicsForDeletion, analyzeOptionsForDeletion, batchDelete } from '../api/googleSheetService.js';
import { showToast } from '../features/toast.js';
import { showDeleteConfirmationModal } from '../features/deleteConfirmationModal.js';

export function initDeleteFunctionality() {
    document.body.addEventListener('click', handleDeleteClick);
}

function determineEntityType(element) {
    const sidePanel = element.closest('.related-section');
    if (sidePanel) {
        const table = sidePanel.querySelector('.pseudo-table');
        if (table) return table.dataset.entityType;
    }
    const activeTab = document.querySelector('.tab-content.active');
    return activeTab ? activeTab.id : 'unknown';
}

async function handleDeleteClick(event) {
    const deleteButton = event.target.closest('.btn-delete');
    if (!deleteButton || deleteButton.disabled) return;

    const entityType = determineEntityType(deleteButton);
    const context = deleteButton.closest('.related-section') || document.querySelector('.tab-content.active');
    if (!context) return;

    const idsToDelete = Array.from(context.querySelectorAll('.row-checkbox:checked')).map(cb => cb.dataset.id);
    if (idsToDelete.length === 0) return;

    let finalIds = null; // Буде об'єктом { categories: [], ... }
    let analysis;

    // --- АНАЛІЗ ---
    try {
        switch (entityType) {
            case 'categories':
                analysis = await analyzeCategoriesForDeletion(idsToDelete);
                break;
            case 'characteristics':
                analysis = await analyzeCharacteristicsForDeletion(idsToDelete);
                break;
            case 'options':
                analysis = await analyzeOptionsForDeletion(idsToDelete);
                break;
            default:
                showToast('Невідомий тип для аналізу.', 'error');
                return;
        }
    } catch(e) {
        showToast('Помилка аналізу залежностей.', 'error');
        return;
    }

    // --- ІНФОРМУВАННЯ ---
    if (analysis.parentsInSelection.length > 0) {
        const userChoice = await showDeleteConfirmationModal(analysis);
        if (userChoice === 'safe') {
            const safeObj = {};
            safeObj[entityType] = analysis.safeToDelete.map(item => item.local_id);
            finalIds = safeObj;
        } else if (userChoice === 'cascade') {
            finalIds = analysis.cascadeDeleteList;
        }
    } else {
        if (confirm(`Ви впевнені, що хочете видалити ${idsToDelete.length} запис(ів)?`)) {
            const idsObj = {};
            idsObj[entityType] = idsToDelete;
            finalIds = idsObj;
        }
    }
    
    // --- ВИКОНАННЯ ---
    if (finalIds && Object.values(finalIds).some(arr => arr.length > 0)) {
        deleteButton.disabled = true;
        const originalLabel = deleteButton.querySelector('.label');
        if (originalLabel) originalLabel.textContent = 'Видалення...';

        try {
            const result = await batchDelete(finalIds);

            if (result.status === 'success') {
                showToast('Записи успішно видалено!', 'success');
                // Оновлюємо всі таблиці, бо видалення могло зачепити кілька сутностей
                document.dispatchEvent(new CustomEvent('dataChanged', { detail: { entityType: 'categories' } }));
                document.dispatchEvent(new CustomEvent('dataChanged', { detail: { entityType: 'characteristics' } }));
                document.dispatchEvent(new CustomEvent('dataChanged', { detail: { entityType: 'options' } }));
            } else {
                showToast(result.message, 'error', 4000);
            }
        } catch (error) {
            console.error('Помилка видалення:', error);
            showToast(`Помилка: ${error.message}`, 'error');
        } finally {
            if (originalLabel) originalLabel.textContent = 'Видалити';
            // Кнопка залишиться неактивною, бо виділення скинеться після оновлення
        }
    }
}
// scripts/actions/import_ui.js
import { getCategories } from '../api/googleSheetService.js';
import { reinitializeCustomSelect } from '../components/select.js';
import { processRztkFile } from './importers/rztk_logic.js';

let logElement, progressBar, summaryElement, startBtn;
let fileToProcess = null;

function log(message) {
    if (logElement) {
        logElement.innerHTML += message + '\n';
        logElement.scrollTop = logElement.scrollHeight;
    }
    console.log(message);
}

function updateProgress(value, total) {
    const percentage = total > 0 ? (value / total) * 100 : 0;
    if (progressBar) {
        progressBar.style.width = `${percentage}%`;
    }
}

function handleFileSelect(file) {
    if (!file || !file.name.endsWith('.xls')) {
        log('Помилка: будь ласка, виберіть файл у форматі .xls');
        startBtn.disabled = true;
        return;
    }
    fileToProcess = file;
    document.getElementById('import-file-name').textContent = `Вибрано файл: ${file.name}`;
    log(`Файл "${file.name}" готовий до імпорту.`);
    startBtn.disabled = false;
}

async function startImportProcess() {
    startBtn.disabled = true;
    logElement.innerHTML = '';
    summaryElement.innerHTML = '';
    updateProgress(0, 1);
    
    const targetCategoryId = document.getElementById('import-target-category').value;

    if (!targetCategoryId || !fileToProcess) {
        log('ПОМИЛКА: Не обрано категорію або файл.');
        startBtn.disabled = false;
        return;
    }
    
    try {
        const summary = await processRztkFile(fileToProcess, targetCategoryId, log, updateProgress);
        summaryElement.innerHTML = `
            <p>✓ Характеристики: Створено <b>${summary.charsCreated}</b> | Оновлено/Знайдено <b>${summary.charsIgnored}</b></p>
            <p>✓ Опції: Створено <b>${summary.optionsCreated}</b> | Проігноровано (вже існували) <b>${summary.optionsIgnored}</b></p>
        `;
        // Сповіщаємо всі таблиці про необхідність оновитись
        document.dispatchEvent(new CustomEvent('dataChanged', { detail: { forceAll: true } }));
    } catch(error) {
        log(`Імпорт зупинено через помилку.`);
    } finally {
        startBtn.disabled = false;
        fileToProcess = null;
    }
}

async function updateCategoryList() {
    const marketplaceSelect = document.getElementById('import-marketplace');
    const categorySelect = document.getElementById('import-target-category');
    const categoryLabel = document.getElementById('import-category-label');
    const selectedMarketplace = marketplaceSelect.value;
    
    categoryLabel.textContent = `Прив'язати до категорії (з ID ${selectedMarketplace})`;
    categorySelect.innerHTML = ''; // Очищуємо список

    const categories = await getCategories();
    // Фільтруємо категорії, які мають ID для вибраного маркетплейсу
    const filteredCategories = categories.filter(c => c[`${selectedMarketplace}_id`] && c[`${selectedMarketplace}_id`].toString().trim() !== '');

    if (filteredCategories.length === 0) {
        log(`ПОПЕРЕДЖЕННЯ: Не знайдено категорій з ID для '${selectedMarketplace}'.`);
    } else {
        filteredCategories.forEach(cat => {
            const option = new Option(cat.name_uk, cat.local_id);
            categorySelect.add(option);
        });
    }
    reinitializeCustomSelect(categorySelect);
}

export async function initImportModal() {
    logElement = document.getElementById('import-log');
    progressBar = document.getElementById('import-progress-bar');
    summaryElement = document.getElementById('import-summary');
    startBtn = document.getElementById('btn-start-import');
    
    const dropArea = document.getElementById('import-drop-area');
    const fileInput = document.getElementById('import-file-input');

    dropArea.addEventListener('click', () => fileInput.click());
    fileInput.addEventListener('change', (e) => handleFileSelect(e.target.files[0]));
    
    ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, (e) => { e.preventDefault(); e.stopPropagation(); }, false);
    });
    ['dragenter', 'dragover'].forEach(eventName => {
        dropArea.addEventListener(eventName, () => dropArea.style.borderColor = 'var(--color-main)');
    });
    ['dragleave', 'drop'].forEach(eventName => {
        dropArea.addEventListener(eventName, () => dropArea.style.borderColor = 'var(--color-outline)');
    });
    dropArea.addEventListener('drop', (e) => handleFileSelect(e.dataTransfer.files[0]));

    startBtn.addEventListener('click', startImportProcess);

    const marketplaceSelect = document.getElementById('import-marketplace');
    const categorySelect = document.getElementById('import-target-category');
    marketplaceSelect.addEventListener('change', updateCategoryList);
    
    log('Ініціалізація... Завантаження категорій...');
    
    const categories = (await getCategories()).filter(c => c.rztk_id && c.rztk_id.toString().trim() !== '');
    
    if (categories.length === 0) {
        log('ПОПЕРЕДЖЕННЯ: Не знайдено жодної категорії з проставленим ID Rozetka.');
    } else {
        categories.forEach(cat => {
            const option = new Option(cat.name_uk, cat.local_id);
            categorySelect.add(option);
        });
    }

    reinitializeCustomSelect(marketplaceSelect);
    reinitializeCustomSelect(categorySelect);
    reinitializeCustomSelect(marketplaceSelect);
    await updateCategoryList(); 
    
    log('Ініціалізація завершена. Оберіть категорію та файл.');
}
// scripts/actions/selection.js (ПОВНА ОНОВЛЕНА ВЕРСІЯ)

import { getPaginationState } from '../components/table.js';

// (НОВЕ) Функції для доступу до стану виділення
export function getSelectedIds(entityType) {
    const state = getPaginationState(entityType);
    return state ? state.selectedIds : new Set();
}

export function isSelected(entityType, id) {
    const selectedIds = getSelectedIds(entityType);
    return selectedIds.has(id);
}

function toggleSelection(entityType, id) {
    const selectedIds = getSelectedIds(entityType);
    if (selectedIds.has(id)) {
        selectedIds.delete(id);
    } else {
        selectedIds.add(id);
    }
}

function selectAllVisible(entityType, table, shouldSelect) {
    const selectedIds = getSelectedIds(entityType);
    const visibleCheckboxes = table.querySelectorAll('.pseudo-table-row:not([style*="display: none"]) .row-checkbox, .pseudo-table-row-inner:not([style*="display: none"]) .row-checkbox');
    
    visibleCheckboxes.forEach(checkbox => {
        const id = checkbox.dataset.id;
        if (shouldSelect) {
            selectedIds.add(id);
        } else {
            selectedIds.delete(id);
        }
        checkbox.checked = shouldSelect;
    });
}

export function initSelection() {
    const rootElement = document.body;

    rootElement.addEventListener('change', (event) => {
        const target = event.target;
        
        if (target.classList.contains('header-select-all')) {
            const table = target.closest('.pseudo-table');
            const entityType = table.closest('.tab-content')?.id;
            if (table && entityType) {
                selectAllVisible(entityType, table, target.checked);
                updateActionButtonsState(table);
            }
        }
        
        const rowCheckbox = target.closest('.row-checkbox');
        if (rowCheckbox) {
            const tableBody = rowCheckbox.closest('.pseudo-table-body');
            const entityType = rowCheckbox.closest('.tab-content')?.id;
            const id = rowCheckbox.dataset.id;

            if (tableBody && entityType && id) {
                toggleSelection(entityType, id);
                updateSelectAllState(tableBody);
                updateActionButtonsState(tableBody);
            }
        }
    });
}

/**
 * Обробляє клік на чекбокс "вибрати все", працює з обома типами таблиць.
 */
function handleSelectAll(headerCheckbox) {
    const table = headerCheckbox.closest('.pseudo-table');
    if (!table) return;

    // Шукаємо рядки обох типів: і в основній таблиці, і в бічній панелі
    const allRows = table.querySelectorAll('.pseudo-table-row, .pseudo-table-row-inner');
    const visibleRows = Array.from(allRows).filter(row => row.style.display !== 'none');
    
    visibleRows.forEach(row => {
        const checkbox = row.querySelector('.row-checkbox');
        if (checkbox) {
            checkbox.checked = headerCheckbox.checked;
        }
    });
}

/**
 * (ОНОВЛЕНО) Оновлює стан головного чекбоксу, працює з обома типами таблиць.
 */
export function updateSelectAllState(tableBody) {
    if (!tableBody) return;
    const table = tableBody.closest('.pseudo-table');
    const headerCheckbox = table.querySelector('.header-select-all');
    if (!headerCheckbox) return;

    // Шукаємо чекбокси в рядках обох типів
    const allCheckboxes = table.querySelectorAll('.pseudo-table-row .row-checkbox, .pseudo-table-row-inner .row-checkbox');
    const visibleCheckboxes = Array.from(allCheckboxes).filter(cb => cb.closest('.pseudo-table-row, .pseudo-table-row-inner').style.display !== 'none');
    
    const checkedVisibleCheckboxes = visibleCheckboxes.filter(cb => cb.checked);

    if (visibleCheckboxes.length > 0 && visibleCheckboxes.length === checkedVisibleCheckboxes.length) {
        headerCheckbox.checked = true;
        headerCheckbox.indeterminate = false;
    } else if (checkedVisibleCheckboxes.length > 0) {
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = true;
    } else {
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = false;
    }
}

export function resetSelection(tableElement) {
    if (!tableElement) return;
    const headerCheckbox = tableElement.querySelector('.header-select-all');
    if (headerCheckbox) {
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = false;
    }
}

/**
 * (НОВА ФУНКЦІЯ)
 * Оновлює стан кнопок дій (напр. "Видалити") на основі кількості виділених рядків.
 * @param {HTMLElement} tableContext - Елемент таблиці або її тіло.
 */
function updateActionButtonsState(tableContext) {
    if (!tableContext) return;

    const checkedCount = tableContext.querySelectorAll('.row-checkbox:checked').length;
    
    // Визначаємо, де шукати кнопку: в бічній панелі чи в основному футері
    const sidePanel = tableContext.closest('.related-section');
    let deleteButton;

    if (sidePanel) {
        deleteButton = sidePanel.querySelector('.btn-delete');
    } else {
        deleteButton = document.querySelector('footer .btn-delete');
    }

    if (deleteButton) {
        deleteButton.disabled = (checkedCount === 0);
    }
}
// scripts/actions/importers/rztk_logic.js
import { getCharacteristics, getOptions, _generateNewId, batchSaveCharacteristics, batchSaveOptions, clearAllCaches } from '../../api/googleSheetService.js';

async function runProcessingLogic(rows, header, targetCategoryId, log, updateProgress) {
    log('3/5: Завантаження існуючих довідників та прив\'язок...');
    // --- ЗМІНА: Завантажуємо і прив'язки ---
    const [existingChars, existingOptions, allMappings] = await Promise.all([
        getCharacteristics(true), 
        getOptions(true),
        getMappings(true) // Додано
    ]);
    
    // --- ЗМІНА: Створюємо сет вже існуючих ID з прив'язок ---
    const mappedRztkIds = new Set(
        allMappings
            .filter(m => m.marketplace === 'Rozetka' && m.marketplace_id)
            .map(m => m.marketplace_id.toString())
    );

    const existingCharsMapRztk = new Map(existingChars.filter(c => c.rztk_id).map(c => [c.rztk_id.toString(), c]));
    const existingOptionsMapRztk = new Map(existingOptions.filter(o => o.rztk_id).map(o => [o.rztk_id.toString(), o]));
    log(`Завантажено ${existingChars.length} характеристик та ${existingOptions.length} опцій.`);

    log('4/5: Аналіз даних...');
    let charsToCreate = [], charsToUpdate = [], optionsToCreate = [];
    let ignoredCharsCount = 0, ignoredOptionsCount = 0;
    const processedCharRztkIds = new Set();

    const h = (name, alternativeName = null) => {
        let index = header.indexOf(name);
        if (index === -1 && alternativeName) {
            index = header.indexOf(alternativeName);
        }
        return index;
    };

    for (const [index, row] of rows.entries()) {
        const rztkParamId = row[h('ID параметра')]?.toString();
        if (!rztkParamId || rztkParamId.trim() === '') continue;

        let char;

        // (ВИПРАВЛЕНО) Шукаємо індекс стовпця з урахуванням можливої одруківки
        const isGlobalIndex = h('Наскрізний параметр', 'Наскрізниий параметр');
        const isGlobal = (row[isGlobalIndex] || '').trim().toLowerCase() === 'так' ? 'TRUE' : 'FALSE';

        if (!processedCharRztkIds.has(rztkParamId)) {
            processedCharRztkIds.add(rztkParamId);
            char = existingCharsMapRztk.get(rztkParamId);

            if (char) { // Оновлення
                let needsUpdate = false;
                if (!char.category_local_ids.includes(targetCategoryId) && isGlobal !== 'TRUE') {
                    char.category_local_ids = [char.category_local_ids, targetCategoryId].filter(Boolean).join(',');
                    needsUpdate = true;
                }
                if (needsUpdate) {
                    charsToUpdate.push(char);
                } else {
                    ignoredCharsCount++;
                }
            } else { // Створення
                char = {
                    local_id: _generateNewId('char', [...existingChars, ...charsToCreate]),
                    name_uk: row[h('Назва параметра')],
                    param_type: row[h('Тип параметра')],
                    filter_type: row[h('Тип фільтра')] === 'main' ? 'Main' : 'Disable',
                    unit: row[h('Одиниця вимірювання')] === 'N/D' ? '' : row[h('Одиниця вимірювання')],
                    is_global: isGlobal,
                    category_local_ids: isGlobal === 'TRUE' ? '' : targetCategoryId,
                    rztk_id: rztkParamId,
                    rztk_name: row[h('Назва параметра')],
                    rztk_param_type: row[h('Тип параметра')],
                    rztk_filter_type: row[h('Тип фільтра')],
                    rztk_unit: row[h('Одиниця вимірювання')],
                };
                charsToCreate.push(char);
            }
        } else {
            char = existingCharsMapRztk.get(rztkParamId) || charsToCreate.find(c => c.rztk_id === rztkParamId);
        }

        const rztkValueId = row[h('ID значення')]?.toString();
        if (rztkValueId && rztkValueId !== 'N/D') {
            if (existingOptionsMapRztk.has(rztkValueId)) {
                ignoredOptionsCount++;
            } else {
                if (!char) continue;
                const option = {
                    local_id: _generateNewId('opt', [...existingOptions, ...optionsToCreate]),
                    name_uk: row[h('Назва значення')],
                    char_local_id: char.local_id,
                    rztk_id: rztkValueId,
                    rztk_name: row[h('Назва значення')],
                };
                optionsToCreate.push(option);
            }
        }

        if ((index + 1) % 50 === 0 || index === rows.length - 1) {
            updateProgress(index + 1, rows.length);
            // Даємо браузеру мить на перемальовку
            await new Promise(resolve => setTimeout(resolve, 0));
        }
    }

    log(`Аналіз завершено.`);
    log('5/5: Збереження даних у Google Sheets...');
    await batchSaveCharacteristics(charsToCreate, charsToUpdate);
    await batchSaveOptions(optionsToCreate, []);

    log('Імпорт завершено!');
    clearAllCaches();

    return {
        charsCreated: charsToCreate.length,
        charsIgnored: charsToUpdate.length + ignoredCharsCount,
        optionsCreated: optionsToCreate.length,
        optionsIgnored: ignoredOptionsCount,
    };
}

export async function processRztkFile(file, targetCategoryId, log, updateProgress) {
    try {
        log('1/5: Читання файлу .xls...');
        const data = await file.arrayBuffer();
        const workbook = XLSX.read(data, { type: 'array' });
        const firstSheetName = workbook.SheetNames[0];
        const worksheet = workbook.Sheets[firstSheetName];
        const jsonData = XLSX.utils.sheet_to_json(worksheet, { header: 1 });

        log('2/5: Парсинг даних...');
        const headerRowIndex = jsonData.findIndex(row => row.includes('ID параметра'));
        if (headerRowIndex === -1) {
            throw new Error("Не вдалося знайти рядок із заголовками ('ID параметра').");
        }
        const header = jsonData[headerRowIndex];
        const rows = jsonData.slice(headerRowIndex + 1);
        log(`Знайдено ${rows.length} рядків для обробки.`);

        return await runProcessingLogic(rows, header, targetCategoryId, log, updateProgress);
    } catch (error) {
        log(`КРИТИЧНА ПОМИЛКА: ${error.message}`);
        throw error;
    }
}
// /scripts/api/auth.js (ВИПРАВЛЕНА ВЕРСІЯ)

import { renderCategoriesTable } from '../components/table.js'; // <-- ДОДАЄМО ІМПОРТ

const CLIENT_ID = '431864072155-l006mvdsf5d67ilevfica0elcc1d0fl8.apps.googleusercontent.com';
const DISCOVERY_DOCS = ["https://sheets.googleapis.com/$discovery/rest?version=v4"];
const SCOPES = "https://www.googleapis.com/auth/spreadsheets";

let tokenClient;
const authorizeButton = document.getElementById('authorize_button');
const signoutButton = document.getElementById('signout_button');

export function initAuth() {
    gapi.load('client', initializeGapiClient);
}

async function initializeGapiClient() {
    await gapi.client.init({ discoveryDocs: DISCOVERY_DOCS });

    const storedToken = localStorage.getItem('google_auth_token');
    if (storedToken) {
        const tokenObject = JSON.parse(storedToken);
        if (tokenObject.expires_at > Date.now()) {
            gapi.client.setToken(tokenObject);
            updateUi(true);
            return; // Виходимо, бо updateUi викличе завантаження таблиці
        } else {
            localStorage.removeItem('google_auth_token');
        }
    }
    
    tokenClient = google.accounts.oauth2.initTokenClient({
        client_id: CLIENT_ID, scope: SCOPES,
        callback: (tokenResponse) => {
            if (tokenResponse && tokenResponse.access_token) {
                tokenResponse.expires_at = Date.now() + (tokenResponse.expires_in * 1000);
                localStorage.setItem('google_auth_token', JSON.stringify(tokenResponse));
                updateUi(true);
            }
        },
    });
    updateUi(false);
}

function updateUi(isSignedIn) {
    if (isSignedIn) {
        authorizeButton.style.display = 'none';
        signoutButton.style.display = 'block';
        renderCategoriesTable();
    } else {
        authorizeButton.style.display = 'block';
        signoutButton.style.display = 'none';
    }
}

authorizeButton.onclick = function handleAuthClick() {
    if (tokenClient) {
        tokenClient.requestAccessToken({prompt: 'consent'});
    }
};

signoutButton.onclick = function handleSignoutClick() {
    const token = gapi.client.getToken();
    if (token !== null) {
        google.accounts.oauth2.revoke(token.access_token);
        gapi.client.setToken('');
        localStorage.removeItem('google_auth_token');
        updateUi(false);
    }
};
// /scripts/api/googleSheetService.js

const SPREADSHEET_ID = '1iFOCQUbisLprSfIkfCar3Oc5f8JW12kA0dpHzjEXSsk';

const SHEET_CONFIG = {
    CATEGORIES: {
        SHEET_ID: 0,
        NAME: 'Categories',
        RANGE: 'Categories!A:Q',
        DATA_TO_ARRAY: (data) => [
            data.local_id, data.parent_local_id, data.name_uk, data.name_ru, data.category_type, 
            data.etalon_id, data.etalon_name, data.rztk_id, data.rztk_name,
            data.epicenter_id, data.epicenter_name, data.allo_id, data.allo_name, 
            data.fua_id, data.fua_name, data.maudau_id, data.maudau_name
        ]
    },
    CHARACTERISTICS: {
        SHEET_ID: 1920085899,
        NAME: 'Characteristics',
        RANGE: 'Characteristics!A:V',
        DATA_TO_ARRAY: (data) => [
            data.local_id, data.name_uk, data.name_ru, data.category_local_ids, data.triggering_option_id,
            data.param_type, data.unit, data.filter_type, data.is_global, data.notes,
            data.etalon_id, data.etalon_name, data.etalon_param_type, data.etalon_filter_type, data.etalon_unit,
            data.rztk_id, data.rztk_name, data.rztk_param_type, data.rztk_filter_type, data.rztk_unit
        ]
    },
    OPTIONS: {
        SHEET_ID: 28101212,
        NAME: 'Options',
        RANGE: 'Options!A:H',
        DATA_TO_ARRAY: (data) => [
            data.local_id, data.char_local_id, data.name_uk, data.name_ru,
            data.etalon_id, data.etalon_name, data.rztk_id, data.rztk_name
        ]
    }
};

let categoryCache = null, characteristicCache = null, optionCache = null;

export function _generateNewId(prefix, allItems) {
    const maxId = allItems.reduce((max, item) => {
        if (item.local_id && item.local_id.startsWith(`${prefix}_`)) {
            const idNum = parseInt(item.local_id.split('_')[1], 10);
            return !isNaN(idNum) && idNum > max ? idNum : max;
        }
        return max;
    }, 0);
    const newIdNumber = maxId + 1;
    const paddedId = String(newIdNumber).padStart(13, '0');
    return `${prefix}_${paddedId}`;
}

async function _deleteRowsByIndexes(sheetId, rowIndexes) {
    if (rowIndexes.length === 0) return;
    rowIndexes.sort((a, b) => b - a);
    const requests = rowIndexes.map(rowIndex => ({
        deleteDimension: {
            range: { sheetId, dimension: 'ROWS', startIndex: rowIndex - 1, endIndex: rowIndex }
        }
    }));
    await gapi.client.sheets.spreadsheets.batchUpdate({
        spreadsheetId: SPREADSHEET_ID,
        resource: { requests }
    });
}

async function _findAndSave(entityData, config, getter) {
    if (!gapi.client.getToken()) return { status: 'error', message: 'Не авторизовано.' };
    try {
        const isNew = !entityData.local_id;
        const allItems = await getter(true);
        if (isNew) {
            entityData.local_id = _generateNewId(config.NAME.slice(0, 3).toLowerCase(), allItems);
        }
        const values = config.DATA_TO_ARRAY(entityData);
        let itemToUpdate = !isNew ? allItems.find(item => item.local_id === entityData.local_id) : null;
        if (itemToUpdate) {
            const range = `${config.NAME}!A${itemToUpdate.rowIndex}`;
            const updateRange = range.split('!')[0] + '!' + range.split('!')[1].split(':')[0] + ':' + String.fromCharCode(65 + values.length - 1) + itemToUpdate.rowIndex;
            await gapi.client.sheets.spreadsheets.values.update({
                spreadsheetId: SPREADSHEET_ID, range: updateRange, valueInputOption: 'USER_ENTERED', resource: { values: [values] }
            });
        } else {
            await gapi.client.sheets.spreadsheets.values.append({
                spreadsheetId: SPREADSHEET_ID, range: config.RANGE, valueInputOption: 'USER_ENTERED', resource: { values: [values] }
            });
        }
        clearAllCaches();
        return { status: 'success', updatedData: entityData };
    } catch (err) {
        console.error(`Помилка збереження для ${config.NAME}:`, err);
        return { status: 'error', message: 'Помилка Google API: ' + err.message };
    }
}

export function clearAllCaches() {
    categoryCache = null; characteristicCache = null; optionCache = null;
    console.log("Усі кеші очищено.");
}

// --- КАТЕГОРІЇ ---
export async function getCategories(forceRefresh = false) {
    if (categoryCache && !forceRefresh) return categoryCache;
    try {
        const response = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: SPREADSHEET_ID, range: 'Categories!A2:R' });
        const values = response.result.values || [];
        categoryCache = values.map((row, index) => ({
            rowIndex: index + 2, local_id: row[0], parent_local_id: row[1], name_uk: row[2],
            name_ru: row[3], category_type: row[4], etalon_id: row[5], etalon_name: row[6],
            rztk_id: row[7], rztk_name: row[8], epicenter_id: row[9], epicenter_name: row[10],
            allo_id: row[11], allo_name: row[12], fua_id: row[13], fua_name: row[14],
            maudau_id: row[15], maudau_name: row[16],
        }));
        return categoryCache;
    } catch (err) { console.error("Помилка завантаження категорій:", err); throw err; }
}

export async function getCategoryById(categoryId, forceRefresh = false) {
    const allCategories = await getCategories(forceRefresh);
    return allCategories.find(category => category.local_id === categoryId) || null;
}

export async function saveCategory(categoryData) { return _findAndSave(categoryData, SHEET_CONFIG.CATEGORIES, getCategories); }

export async function analyzeCategoriesForDeletion(ids) {
    const allCategories = await getCategories(true);
    const categoriesMap = new Map(allCategories.map(c => [c.local_id, c]));
    const selectedCategories = ids.map(id => categoriesMap.get(id)).filter(Boolean);
    const parentIdsWithChildren = new Set(allCategories.map(c => c.parent_local_id).filter(Boolean));
    const parentsInSelection = [];
    const safeToDelete = [];
    for (const category of selectedCategories) {
        if (parentIdsWithChildren.has(category.local_id)) {
            const children = allCategories.filter(c => c.parent_local_id === category.local_id);
            parentsInSelection.push({ ...category, children });
        } else {
            safeToDelete.push(category);
        }
    }
    let cascadeDeleteSet = new Set();
    if (parentsInSelection.length > 0) {
        let toProcess = parentsInSelection.map(p => p.local_id);
        while (toProcess.length > 0) {
            const currentId = toProcess.shift();
            if (!cascadeDeleteSet.has(currentId)) {
                cascadeDeleteSet.add(currentId);
                const children = allCategories.filter(c => c.parent_local_id === currentId);
                toProcess.push(...children.map(c => c.local_id));
            }
        }
    }
    safeToDelete.forEach(c => cascadeDeleteSet.add(c.local_id));
    return { parentsInSelection, safeToDelete, cascadeDeleteList: Array.from(cascadeDeleteSet) };
}

export async function analyzeCharacteristicsForDeletion(ids) {
    const [allChars, allOptions] = await Promise.all([getCharacteristics(true), getOptions(true)]);
    const charsMap = new Map(allChars.map(c => [c.local_id, c]));
    
    const parentsInSelection = [];
    const safeToDelete = [];

    // Створюємо мапу для швидкого пошуку опцій за ID характеристики
    const optionsByCharId = new Map();
    allOptions.forEach(opt => {
        if (!optionsByCharId.has(opt.char_local_id)) {
            optionsByCharId.set(opt.char_local_id, []);
        }
        optionsByCharId.get(opt.char_local_id).push(opt);
    });

    for (const id of ids) {
        const char = charsMap.get(id);
        if (!char) continue;

        const linkedOptions = optionsByCharId.get(id) || [];
        if (linkedOptions.length > 0) {
            parentsInSelection.push({ ...char, linkedEntities: linkedOptions, entityType: 'options' });
        } else {
            safeToDelete.push(char);
        }
    }

    const cascadeDeleteList = { characteristics: [], options: [] };
    parentsInSelection.forEach(p => {
        cascadeDeleteList.characteristics.push(p.local_id);
        p.linkedEntities.forEach(opt => cascadeDeleteList.options.push(opt.local_id));
    });
    safeToDelete.forEach(c => cascadeDeleteList.characteristics.push(c.local_id));

    return { parentsInSelection, safeToDelete, cascadeDeleteList };
}

export async function analyzeOptionsForDeletion(ids) {
    const [allOptions, allChars] = await Promise.all([getOptions(true), getCharacteristics(true)]);
    const optionsMap = new Map(allOptions.map(o => [o.local_id, o]));
    
    const triggersInSelection = [];
    const safeToDelete = [];

    const charsByTriggerId = new Map();
    allChars.forEach(char => {
        if (char.triggering_option_id) {
            if (!charsByTriggerId.has(char.triggering_option_id)) {
                charsByTriggerId.set(char.triggering_option_id, []);
            }
            charsByTriggerId.get(char.triggering_option_id).push(char);
        }
    });

    for (const id of ids) {
        const option = optionsMap.get(id);
        if (!option) continue;

        const triggeredChars = charsByTriggerId.get(id) || [];
        if (triggeredChars.length > 0) {
            triggersInSelection.push({ ...option, linkedEntities: triggeredChars, entityType: 'characteristics' });
        } else {
            safeToDelete.push(option);
        }
    }
        const cascadeDeleteList = { options: [], characteristics: [] };
    triggersInSelection.forEach(t => {
        cascadeDeleteList.options.push(t.local_id);
        t.linkedEntities.forEach(char => cascadeDeleteList.characteristics.push(char.local_id));
    });
    safeToDelete.forEach(o => cascadeDeleteList.options.push(o.local_id));
    
    // Потрібно також знайти і видалити опції, що належали характеристикам, які ми видаляємо
    const charsToDeleteCascaded = cascadeDeleteList.characteristics;
    const allOptionsToDelete = new Set(cascadeDeleteList.options);
    allOptions.forEach(opt => {
        if (charsToDeleteCascaded.includes(opt.char_local_id)) {
            allOptionsToDelete.add(opt.local_id);
        }
    });
    cascadeDeleteList.options = Array.from(allOptionsToDelete);

    // `parentsInSelection` - це узагальнена назва для сутностей із залежностями
    return { parentsInSelection: triggersInSelection, safeToDelete, cascadeDeleteList };
}

/**
 * (НОВА ФУНКЦІЯ) Пакетно видаляє записи з різних таблиць.
 * @param {object} itemsToDelete - Об'єкт з масивами ID для видалення, напр. { categories: [...], options: [...] }
 */
export async function batchDelete(itemsToDelete) {
    if (Object.keys(itemsToDelete).length === 0) return { status: 'success' };
    
    try {
        const [allCategories, allCharacteristics, allOptions] = await Promise.all([
            getCategories(true), getCharacteristics(true), getOptions(true)
        ]);
        
        const requests = [];

        if (itemsToDelete.categories?.length > 0) {
            const rowIndexes = allCategories.filter(c => itemsToDelete.categories.includes(c.local_id)).map(c => c.rowIndex);
            requests.push(...rowIndexes.map(idx => ({ sheetId: SHEET_CONFIG.CATEGORIES.SHEET_ID, rowIndex: idx })));
        }
        if (itemsToDelete.characteristics?.length > 0) {
            const rowIndexes = allCharacteristics.filter(c => itemsToDelete.characteristics.includes(c.local_id)).map(c => c.rowIndex);
            requests.push(...rowIndexes.map(idx => ({ sheetId: SHEET_CONFIG.CHARACTERISTICS.SHEET_ID, rowIndex: idx })));
        }
        if (itemsToDelete.options?.length > 0) {
            const rowIndexes = allOptions.filter(o => itemsToDelete.options.includes(o.local_id)).map(o => o.rowIndex);
            requests.push(...rowIndexes.map(idx => ({ sheetId: SHEET_CONFIG.OPTIONS.SHEET_ID, rowIndex: idx })));
        }

        const uniqueRequests = Array.from(new Map(requests.map(r => [`${r.sheetId}-${r.rowIndex}`, r])).values());
        
        uniqueRequests.sort((a, b) => b.rowIndex - a.rowIndex);
        
        const batchRequests = uniqueRequests.map(req => ({
            deleteDimension: {
                range: { sheetId: req.sheetId, dimension: 'ROWS', startIndex: req.rowIndex - 1, endIndex: req.rowIndex }
            }
        }));

        if(batchRequests.length > 0) {
            await gapi.client.sheets.spreadsheets.batchUpdate({
                spreadsheetId: SPREADSHEET_ID,
                resource: { requests: batchRequests }
            });
        }
        
        clearAllCaches();
        return { status: 'success' };
    } catch (error) {
        console.error("Помилка в batchDelete:", error);
        return { status: 'error', message: `Помилка API: ${error.result?.error?.message || error.message}` };
    }
}

export async function deleteCategoriesByIds(finalIdsToDelete) {
    try {
        const allCategories = await getCategories(true);
        const rowIndexesToDelete = allCategories
            .filter(cat => finalIdsToDelete.includes(cat.local_id))
            .map(cat => cat.rowIndex)
            .filter(Boolean);
        await _deleteRowsByIndexes(SHEET_CONFIG.CATEGORIES.SHEET_ID, rowIndexesToDelete);
        clearAllCaches();
        return { status: 'success' };
    } catch (error) {
        console.error("Помилка в deleteCategoriesByIds:", error);
        return { status: 'error', message: `Помилка API: ${error.result?.error?.message || error.message}` };
    }
}

// --- ХАРАКТЕРИСТИКИ ---
export async function getCharacteristics(forceRefresh = false) {
    if (characteristicCache && !forceRefresh) return characteristicCache;
    try {
        const response = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: SPREADSHEET_ID, range: 'Characteristics!A2:V' });
        const values = response.result.values || [];
        characteristicCache = values.map((row, index) => ({
            rowIndex: index + 2, local_id: row[0], name_uk: row[1], name_ru: row[2],
            category_local_ids: row[3] || '', triggering_option_id: row[4], param_type: row[5], unit: row[6],
            filter_type: row[7], is_global: row[8], notes: row[9] || '',
            etalon_id: row[10], etalon_name: row[11], etalon_param_type: row[12], etalon_filter_type: row[13], etalon_unit: row[14],
            rztk_id: row[15], rztk_name: row[16], rztk_param_type: row[17], rztk_filter_type: row[18], rztk_unit: row[19],
        }));
        return characteristicCache;
    } catch (err) { console.error("Помилка завантаження характеристик:", err); throw err; }
}

export async function getCharacteristicById(charId, forceRefresh = false) {
    const allCharacteristics = await getCharacteristics(forceRefresh);
    return allCharacteristics.find(c => c.local_id === charId) || null;
}

export async function saveCharacteristic(charData) { return _findAndSave(charData, SHEET_CONFIG.CHARACTERISTICS, getCharacteristics); }

export async function deleteCharacteristicsByIds(idsToDelete) {
    try {
        const [allOptions, allCharacteristics] = await Promise.all([getOptions(true), getCharacteristics(true)]);
        const optionsParentIds = new Set(allOptions.map(opt => opt.char_local_id));
        const characteristicsToDelete = allCharacteristics.filter(char => idsToDelete.includes(char.local_id));
        for (const char of characteristicsToDelete) {
            if (optionsParentIds.has(char.local_id)) {
                return { status: 'error', message: `Не можна видалити '${char.name_uk}', бо до неї прив'язані опції.` };
            }
        }
        const rowIndexesToDelete = characteristicsToDelete.map(c => c.rowIndex).filter(Boolean);
        await _deleteRowsByIndexes(SHEET_CONFIG.CHARACTERISTICS.SHEET_ID, rowIndexesToDelete);
        clearAllCaches();
        return { status: 'success' };
    } catch (error) {
        return { status: 'error', message: `Помилка API: ${error.result?.error?.message || error.message}` };
    }
}

// --- ОПЦІЇ ---
export async function getOptions(forceRefresh = false) {
    if (optionCache && !forceRefresh) return optionCache;
    try {
        const response = await gapi.client.sheets.spreadsheets.values.get({ spreadsheetId: SPREADSHEET_ID, range: 'Options!A2:H' });
        const values = response.result.values || [];
        optionCache = values.map((row, index) => ({
            rowIndex: index + 2, local_id: row[0], char_local_id: row[1], name_uk: row[2], name_ru: row[3],
            etalon_id: row[4], etalon_name: row[5], rztk_id: row[6], rztk_name: row[7],
        }));
        return optionCache;
    } catch (err) { console.error("Помилка завантаження опцій:", err); throw err; }
}

export async function getOptionById(optionId, forceRefresh = false) {
    const allOptions = await getOptions(forceRefresh);
    return allOptions.find(option => option.local_id === optionId) || null;
}

export async function saveOption(optionData) { return _findAndSave(optionData, SHEET_CONFIG.OPTIONS, getOptions); }

export async function deleteOptionsByIds(idsToDelete) {
    try {
        const [allChars, allOptions] = await Promise.all([getCharacteristics(true), getOptions(true)]);
        const triggerIds = new Set(allChars.map(c => c.triggering_option_id));
        for (const id of idsToDelete) {
            if (triggerIds.has(id)) {
                return { status: 'error', message: `Не можна видалити опцію з ID ${id}, бо вона є тригером.` };
            }
        }
        const rowIndexesToDelete = allOptions.filter(opt => idsToDelete.includes(opt.local_id)).map(o => o.rowIndex).filter(Boolean);
        await _deleteRowsByIndexes(SHEET_CONFIG.OPTIONS.SHEET_ID, rowIndexesToDelete);
        clearAllCaches();
        return { status: 'success' };
    } catch (error) {
        return { status: 'error', message: `Помилка API: ${error.result?.error?.message || error.message}` };
    }
}

// --- ЗВ'ЯЗКИ ---
export async function getChildCategories(parentId) {
    const allCategories = await getCategories();
    return allCategories.filter(category => category.parent_local_id === parentId);
}

export async function getLinkedCharacteristics(categoryId) {
    const allCharacteristics = await getCharacteristics();
    return allCharacteristics.filter(char => {
        if (char.is_global === 'TRUE') return true;
        if (char.category_local_ids) {
            const categoryIds = char.category_local_ids.split(',').map(id => id.trim());
            return categoryIds.includes(categoryId);
        }
        return false;
    });
}

export async function getOptionsForCharacteristic(characteristicId) {
    const allOptions = await getOptions();
    return allOptions.filter(option => option.char_local_id === characteristicId);
}

export async function getCharacteristicsTriggeredByOption(optionId) {
    const allCharacteristics = await getCharacteristics();
    return allCharacteristics.filter(char => char.triggering_option_id === optionId);
}


// --- ПАКЕТНІ ОПЕРАЦІЇ ---
// (ВИПРАВЛЕНО) Додано `export`, щоб зробити функції доступними для імпортера
export async function _batchAppend(sheetName, dataArrays) {
    if (dataArrays.length === 0) return;
    await gapi.client.sheets.spreadsheets.values.append({
        spreadsheetId: SPREADSHEET_ID, range: `${sheetName}!A:A`, valueInputOption: 'USER_ENTERED', resource: { values: dataArrays }
    });
}
export async function _batchUpdate(sheetName, data) {
    if (data.length === 0) return;
    const dataForUpdate = data.map(item => ({
        range: `${sheetName}!A${item.rowIndex}:${String.fromCharCode(65 + item.values.length - 1)}${item.rowIndex}`,
        values: [item.values]
    }));
    await gapi.client.sheets.spreadsheets.values.batchUpdate({
        spreadsheetId: SPREADSHEET_ID, resource: { valueInputOption: 'USER_ENTERED', data: dataForUpdate }
    });
}

export async function batchSaveCharacteristics(toCreate, toUpdate) {
    const creator = SHEET_CONFIG.CHARACTERISTICS.DATA_TO_ARRAY;
    if (toCreate.length > 0) await _batchAppend('Characteristics', toCreate.map(creator));
    if (toUpdate.length > 0) {
        const updater = toUpdate.map(d => ({ rowIndex: d.rowIndex, values: creator(d) }));
        await _batchUpdate('Characteristics', updater);
    }
}

export async function batchSaveOptions(toCreate, toUpdate) {
    const creator = SHEET_CONFIG.OPTIONS.DATA_TO_ARRAY;
    if (toCreate.length > 0) await _batchAppend('Options', toCreate.map(creator));
    if (toUpdate.length > 0) {
        const updater = toUpdate.map(d => ({ rowIndex: d.rowIndex, values: creator(d) }));
        await _batchUpdate('Options', updater);
    }
}
// scripts/components/controls.js

import { clearAllCaches } from '../api/googleSheetService.js';
import { showToast } from '../features/toast.js';
import { renderCategoriesTable, renderCharacteristicsTable, renderOptionsTable } from './table.js';

export function initControls() {
    const refreshBtn = document.getElementById('refreshDataBtn');
    if (refreshBtn) {
        refreshBtn.addEventListener('click', handleRefreshData);
    }
}

async function handleRefreshData(event) {
    const button = event.currentTarget;
    showToast('Оновлення даних...', 'info', 1500);

    // Просто блокуємо кнопку на час операції
    button.disabled = true;
    
    // 1. Очищуємо всі кеші
    clearAllCaches();

    // 2. Визначаємо активну вкладку
    const activeTabContent = document.querySelector('.tab-content.active');
    if (!activeTabContent) {
        showToast('Не вдалося визначити активну вкладку.', 'error');
        button.disabled = false;
        return;
    }

    const tabId = activeTabContent.id;

    // 3. Рендеримо дані для активної вкладки
    try {
        switch (tabId) {
            case 'categories':
                await renderCategoriesTable();
                break;
            case 'characteristics':
                await renderCharacteristicsTable();
                break;
            case 'options':
                await renderOptionsTable();
                break;
        }
        showToast('Дані успішно оновлено!', 'success');
    } catch (error) {
        console.error("Помилка при оновленні даних:", error);
        showToast('Помилка під час оновлення даних. Перевірте авторизацію.', 'error');
    } finally {
        // Повертаємо кнопку в активний стан
        button.disabled = false;
    }
}
// /scripts/components/modal.js (ПОВНА, ВІДНОВЛЕНА ТА ВИПРАВЛЕНА ВЕРСІЯ) 11:17

import {
    getCategories, saveCategory, getChildCategories, getLinkedCharacteristics, getCategoryById,
    getOptions, saveCharacteristic, getCharacteristicById, getOptionById, getCharacteristics,
    saveOption, getOptionsForCharacteristic
} from '../api/googleSheetService.js';
import { showToast } from '../features/toast.js';
import { reinitializeCustomSelect } from './select.js';
import { getPaginationState } from './table.js';
import { updateSortUI } from '../features/sorting.js';
import { updateSelectAllState } from '../actions/selection.js'; 

const modalPlaceholder = document.getElementById('modal-placeholder');
let modalHistory = [];
// Для зберігання вихідних даних бічних панелей для пошуку
let sidePanelDataSources = {};

// ========================================================================
// === CORE MODAL FUNCTIONS (Основні функції модального вікна) ===
// ========================================================================

export async function loadAndShowModal(modalName, data = null) {
    let initialData = data || {};
    sidePanelDataSources = {};

    if (data && data.local_id) {
        try {
            let freshData = null;
            const forceRefresh = true;
            switch(modalName) {
                case 'category-form':
                    freshData = await getCategoryById(data.local_id, forceRefresh);
                    break;
                case 'characteristic-form':
                    freshData = await getCharacteristicById(data.local_id, forceRefresh);
                    break;
                case 'option-form':
                    freshData = await getOptionById(data.local_id, forceRefresh);
                    break;
            }
            if (freshData) {
                initialData = freshData;
            } else {
                showToast('Не вдалося знайти запис. Можливо, він був видалений.', 'error');
                const entityType = modalName.split('-')[0] + 's';
                document.dispatchEvent(new CustomEvent('dataChanged', { detail: { entityType: entityType } }));
                return;
            }
        } catch (error) {
            console.error("Помилка при оновленні даних перед відкриттям форми:", error);
            showToast('Помилка завантаження свіжих даних. Перевірте підключення.', 'error');
        }
    }

    modalHistory = [initialData];
    try {
        const modalPath = `modals/${modalName}.html`;
        const response = await fetch(modalPath);
        if (!response.ok) throw new Error(`Не вдалося завантажити шаблон: ${response.statusText}`);
        
        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = await response.text();
        const modalElement = tempDiv.firstElementChild;
        modalPlaceholder.appendChild(modalElement);

        const contentEl = modalElement.querySelector('.modal-content');
        if (contentEl) contentEl.dataset.formType = modalName;

        try {
            switch(modalName) {
                case 'category-form':
                    await renderCategoryFormContent(contentEl, initialData);
                    break;
                case 'characteristic-form':
                    await renderCharacteristicFormContent(contentEl, initialData);
                    break;
                case 'option-form':
                    await renderOptionFormContent(contentEl, initialData);
                    break;
            }
        } catch (renderError) {
            console.error(`Помилка під час рендерингу вмісту модального вікна (${modalName}):`, renderError);
            showToast('Помилка відображення даних форми.', 'error');
             if (contentEl) {
                contentEl.innerHTML = `<div class="modal-header"><h2 id="modal-title">Помилка</h2></div>
                                       <div class="modal-body" style="padding: 20px; color: red;">Не вдалося завантажити дані для форми.</div>`;
            }
        }

        initModalLogic(modalElement);
        document.addEventListener('dataChanged', handleDataChangeForModal);
        document.addEventListener('sidePanelSortChanged', handleSidePanelSortForModal);

    } catch (error) {
        console.error('Помилка при завантаженні модального вікна:', error);
        showToast('Помилка при завантаженні модального вікна', 'error');
    }
}

function closeModal() {
    if (modalPlaceholder.lastChild) {
        modalPlaceholder.removeChild(modalPlaceholder.lastChild);
    }
    modalHistory = [];
    sidePanelDataSources = {};
    document.removeEventListener('dataChanged', handleDataChangeForModal);
    document.removeEventListener('sidePanelSortChanged', handleSidePanelSortForModal);
}

// ========================================================================
// === EVENT HANDLERS (Обробники подій) ===
// ========================================================================

async function handleDataChangeForModal(event) {
    const modalContentEl = modalPlaceholder.querySelector('.modal-overlay .modal-content');
    if (!modalContentEl || modalHistory.length === 0) return;
    const currentData = modalHistory[modalHistory.length - 1];
    if (!currentData.local_id) return;
    const formType = modalContentEl.dataset.formType;
    let freshData = null;
    let renderFunction = null;

    try {
        const forceRefresh = true;
        switch(formType) {
            case 'category-form':
                if (['categories', 'characteristics'].includes(event.detail.entityType)) {
                    freshData = await getCategoryById(currentData.local_id, forceRefresh);
                    renderFunction = renderCategoryFormContent;
                }
                break;
            case 'characteristic-form':
                 if (['characteristics', 'options', 'categories'].includes(event.detail.entityType)) {
                    freshData = await getCharacteristicById(currentData.local_id, forceRefresh);
                    renderFunction = renderCharacteristicFormContent;
                }
                break;
            case 'option-form':
                if (['options', 'characteristics'].includes(event.detail.entityType)) {
                    freshData = await getOptionById(currentData.local_id, forceRefresh);
                    renderFunction = renderOptionFormContent;
                }
                break;
        }
    } catch (error) {
        console.error("Помилка при оновленні даних в модальному вікні:", error);
        return;
    }

    if (!renderFunction) return;

    if (freshData) {
        modalHistory[modalHistory.length - 1] = freshData;
        await renderFunction(modalContentEl, freshData);
    } else {
        showToast('Сутність, яку ви редагували, було видалено.', 'info');
        closeModal();
    }
}

function handleSidePanelSortForModal(event) {
    const { entityType } = event.detail || {};
    const modalEl = modalPlaceholder.querySelector('.modal-overlay .modal-content');
    if (!modalEl) return;
    const visiblePanel = modalEl.querySelector('.related-section.visible');
    const table = visiblePanel ? visiblePanel.querySelector('.pseudo-table') : null;
    if (table) {
        sortSidePanelTable(table, entityType);
        updateSortUI(entityType);
    }
}

function sortSidePanelTable(table, entityType) {
    const state = getPaginationState(entityType);
    if (!state || !state.sortKey) return;
    const { sortKey, sortOrder } = state;
    const body = table.querySelector('.pseudo-table-body');
    const rows = Array.from(body.querySelectorAll('.pseudo-table-row-inner'));
    const headerCells = Array.from(table.querySelectorAll('.pseudo-table-header .sortable-header'));
    const sortIndex = headerCells.findIndex(cell => cell.dataset.sortKey === sortKey);
    if (sortIndex === -1) return;
    rows.sort((a, b) => {
        const cellsA = a.querySelectorAll('.pseudo-table-cell:not(.cell-actions)');
        const cellsB = b.querySelectorAll('.pseudo-table-cell:not(.cell-actions)');
        const valA = (cellsA[sortIndex]?.textContent || '').trim();
        const valB = (cellsB[sortIndex]?.textContent || '').trim();
        return sortOrder === 'asc' ? valA.localeCompare(valB) : valB.localeCompare(valA);
    });
    rows.forEach(row => body.appendChild(row));
}


// ========================================================================
// === CATEGORY FORM LOGIC (Логіка для форми Категорій) ===
// ========================================================================

async function renderCategoryFormContent(modalEl, data) {
    const isEditing = !!data.local_id;
    const titleEl = modalEl.querySelector('#modal-title');
    const backBtn = modalEl.querySelector('#modal-back-btn');

    if (modalHistory.length > 1) {
        if (titleEl) titleEl.innerText = `Дочірня категорія "${data.name_uk || ''}"`;
        if (backBtn) backBtn.style.display = 'block';
    } else {
        if (titleEl) titleEl.innerText = isEditing ? `Редагування категорії "${data.name_uk || ''}"` : 'Створити категорію';
        if (backBtn) backBtn.style.display = 'none';
    }

    modalEl.querySelector('.modal-body--split')?.classList.remove('side-panel-visible');
    modalEl.querySelector('#children-panel')?.classList.remove('visible');
    modalEl.querySelector('#characteristics-panel')?.classList.remove('visible');
    modalEl.querySelectorAll('.header-actions .segment.active').forEach(btn => btn.classList.remove('active'));

    await populateParentCategorySelect(modalEl, data);
    populateCategoryForm(modalEl, data);
    const parentSelect = modalEl.querySelector('#cat-parent_local_id');
    if (parentSelect) reinitializeCustomSelect(parentSelect);

    const childrenBtn = modalEl.querySelector('#show-children-btn');
    if (childrenBtn) childrenBtn.style.display = 'none';
    const charsBtn = modalEl.querySelector('#show-chars-btn');
    if (charsBtn) charsBtn.style.display = 'none';

    if (isEditing) {
        await loadSidePanelsData(modalEl, data.local_id);
    }
}

function buildHierarchicalCategoryList(allCategories, excludeId = null) {
    const categoryMap = new Map(allCategories.map(c => [c.local_id, { ...c }]));
    const hierarchicalList = [];
    for (const category of allCategories) {
        if (category.local_id === excludeId) continue;
        let path = [category.name_uk];
        let level = 0;
        let current = category;
        const visited = new Set([category.local_id]);
        while (current.parent_local_id && categoryMap.has(current.parent_local_id)) {
            current = categoryMap.get(current.parent_local_id);
             if (visited.has(current.local_id)) {
                console.error("Циклічне посилання виявлено:", current.local_id);
                break; 
            }
            visited.add(current.local_id);
            path.unshift(current.name_uk);
            level++;
        }
        hierarchicalList.push({ ...category, level, fullName: path.join(' > ') });
    }
    hierarchicalList.sort((a, b) => a.fullName.localeCompare(b.fullName));
    return hierarchicalList;
}

async function populateParentCategorySelect(modalEl, currentCategoryData) {
    const select = modalEl.querySelector('#cat-parent_local_id');
    if (!select) return;
    while (select.options.length > 1) select.remove(1); // Зберігаємо перший "-- Коренева --"
    const allCategories = await getCategories();
    const hierarchicalCategories = buildHierarchicalCategoryList(allCategories, currentCategoryData.local_id);
    hierarchicalCategories.forEach(cat => {
        const option = new Option(cat.fullName, cat.local_id); // Text content = повний шлях
        option.dataset.htmlContent = `${'&nbsp;'.repeat(cat.level * 4)}${cat.name_uk}`;
        select.add(option);
    });
}

function populateCategoryForm(modalEl, data) {
    const safeSetValue = (selector, value) => {
        const element = modalEl.querySelector(selector);
        if (element) element.value = value || '';
    };
    const safeSetToggle = (selector, value, onValue = 'leaf') => {
        const element = modalEl.querySelector(selector);
        if (element) element.checked = (value === onValue);
    };

    safeSetValue('#cat-local_id', data.local_id);
    safeSetValue('#cat-parent_local_id', data.parent_local_id);
    safeSetToggle('#cat-category_type', data.category_type, 'leaf');
    safeSetValue('#cat-name_uk', data.name_uk);
    safeSetValue('#cat-name_ru', data.name_ru);
    safeSetValue('#cat-etalon_id', data.etalon_id);
    safeSetValue('#cat-etalon_name', data.etalon_name);
    safeSetValue('#cat-rztk_id', data.rztk_id);
    safeSetValue('#cat-rztk_name', data.rztk_name);
    safeSetValue('#cat-epicenter_id', data.epicenter_id);
    safeSetValue('#cat-epicenter_name', data.epicenter_name);
    safeSetValue('#cat-allo_id', data.allo_id);
    safeSetValue('#cat-allo_name', data.allo_name);
    safeSetValue('#cat-fua_id', data.fua_id);
    safeSetValue('#cat-fua_name', data.fua_name);
    safeSetValue('#cat-maudau_id', data.maudau_id);
    safeSetValue('#cat-maudau_name', data.maudau_name);
}

function getCategoryDataFromForm(modalEl) {
    const getValue = (selector) => modalEl.querySelector(selector)?.value || '';
    const getToggleValue = (selector, onValue = 'leaf', offValue = 'grouping') => modalEl.querySelector(selector)?.checked ? onValue : offValue;
    return {
        local_id: getValue('#cat-local_id'),
        parent_local_id: getValue('#cat-parent_local_id'),
        category_type: getToggleValue('#cat-category_type'),
        name_uk: getValue('#cat-name_uk').trim(),
        name_ru: getValue('#cat-name_ru').trim(),
        etalon_id: getValue('#cat-etalon_id').trim(),
        etalon_name: getValue('#cat-etalon_name').trim(),
        rztk_id: getValue('#cat-rztk_id').trim(),
        rztk_name: getValue('#cat-rztk_name').trim(),
        epicenter_id: getValue('#cat-epicenter_id').trim(),
        epicenter_name: getValue('#cat-epicenter_name').trim(),
        allo_id: getValue('#cat-allo_id').trim(),
        allo_name: getValue('#cat-allo_name').trim(),
        fua_id: getValue('#cat-fua_id').trim(),
        fua_name: getValue('#cat-fua_name').trim(),
        maudau_id: getValue('#cat-maudau_id').trim(),
        maudau_name: getValue('#cat-maudau_name').trim(),
    };
}

// ========================================================================
// === CHARACTERISTIC FORM LOGIC (Відновлена логіка) ===
// ========================================================================

async function renderCharacteristicFormContent(modalEl, data) {
    const isEditing = !!data.local_id;
    const titleEl = modalEl.querySelector('#modal-title');
    if (titleEl) titleEl.innerText = isEditing ? `Редагування характеристики "${data.name_uk || ''}"` : 'Створити характеристику';

    modalEl.querySelector('#options-panel')?.classList.remove('visible');
    modalEl.querySelector('#show-options-btn')?.classList.remove('active');
    modalEl.querySelector('.modal-body--split')?.classList.remove('side-panel-visible');

    const optionsBtn = modalEl.querySelector('#show-options-btn');
    if (optionsBtn) optionsBtn.style.display = 'none';

    await Promise.all([
        populateAllCategoriesSelect(modalEl, data.category_local_ids),
        populateAllOptionsSelect(modalEl, data.triggering_option_id, data)
    ]);
    populateCharacteristicForm(modalEl, data);
    
    // (ОНОВЛЕНО) Цей код тепер знаходить і ініціалізує ВСІ кастомні селекти в модальному вікні
    modalEl.querySelectorAll('select[data-custom-select]').forEach(selectEl => {
        if (selectEl) {
            reinitializeCustomSelect(selectEl);
        }
    });

    initGlobalParamToggle(modalEl);

    if (isEditing) {
        const optionsContainer = modalEl.querySelector('#options-panel .related-content-container');
        if (optionsContainer) optionsContainer.innerHTML = '<p>Завантаження опцій...</p>';
        const options = await getOptionsForCharacteristic(data.local_id);
        if (options.length > 0) {
            if (optionsBtn) optionsBtn.style.display = 'block';
            if (optionsContainer) optionsContainer.innerHTML = await generateSidePanelTableHTML('options', "Опції", { name_uk: "Назва" }, options, 'modals/partials/options-panel-table.html');
        } else if (optionsContainer) {
            optionsContainer.innerHTML = '<p style="padding: 16px;">Опції для цієї характеристики відсутні.</p>';
        }
    }
}


async function populateAllCategoriesSelect(modalEl, selectedIds = '') {
    const select = modalEl.querySelector('#char-category_local_ids');
    if (!select) return;
    select.innerHTML = '';
    const selectedIdSet = new Set((selectedIds || '').split(',').map(id => id.trim()));
    const allCategories = await getCategories();
    const hierarchicalCategories = buildHierarchicalCategoryList(allCategories);
    hierarchicalCategories.forEach(cat => {
        const option = new Option(cat.fullName, cat.local_id); // Text content = повний шлях
        option.selected = selectedIdSet.has(cat.local_id);
        option.dataset.name = cat.name_uk;
        option.dataset.level = cat.level;
        option.dataset.htmlContent = `${'&nbsp;'.repeat(cat.level * 4)}${cat.name_uk}`;
        select.add(option);
    });
}

async function populateAllOptionsSelect(modalEl, selectedId, currentCharacteristicData) {
    const select = modalEl.querySelector('#char-triggering_option_id');
    if (!select) return;
    select.innerHTML = '<option value="">-- Не належить --</option>';

    // Отримуємо всі опції та всі характеристики
    const [allOptions, allCharacteristics] = await Promise.all([getOptions(), getCharacteristics()]);

    // Створюємо мапу характеристик для швидкого доступу
    const charMap = new Map(allCharacteristics.map(char => [char.local_id, char]));

    // Отримуємо ID категорій поточної характеристики, яку редагуємо
    const currentCategoryIds = new Set(
        (currentCharacteristicData.category_local_ids || '').split(',').map(id => id.trim()).filter(Boolean)
    );

    // Фільтруємо опції за новими правилами
    const filteredOptions = allOptions.filter(option => {
        const parentChar = charMap.get(option.char_local_id);
        if (!parentChar) return false; // Опція без батька не може бути тригером

        // Правило 1: Батьківська характеристика НЕ повинна бути глобальною
        const isNotGlobal = parentChar.is_global !== 'TRUE';
        if (!isNotGlobal) return false;

        // Правило 2: Батьківська характеристика повинна бути в тій же категорії
        const parentCategoryIds = (parentChar.category_local_ids || '').split(',').map(id => id.trim());
        const hasCommonCategory = parentCategoryIds.some(id => currentCategoryIds.has(id));
        
        return hasCommonCategory;
    });

    filteredOptions.sort((a, b) => (a.name_uk || '').localeCompare(b.name_uk || ''));
    filteredOptions.forEach(opt => {
        const option = new Option(opt.name_uk, opt.local_id);
        option.selected = (opt.local_id === selectedId);
        select.add(option);
    });
}


function populateCharacteristicForm(modalEl, data) {
    const safeSetValue = (selector, value) => {
        const element = modalEl.querySelector(selector);
        if (element) element.value = value || '';
    };
    const safeSetCheckbox = (selector, value) => {
        const element = modalEl.querySelector(selector);
        if (element) element.checked = (value === 'TRUE' || value === true);
    };
    // (НОВЕ) Встановлюємо значення для нового перемикача "Тип фільтра"
    const safeSetToggle = (selector, value, onValue) => {
        const element = modalEl.querySelector(selector);
        if(element) element.checked = (value === onValue);
    };

    safeSetCheckbox('#char-is_global', data.is_global);

    safeSetValue('#char-local_id', data.local_id);
    safeSetValue('#char-name_uk', data.name_uk);
    safeSetValue('#char-name_ru', data.name_ru);
    safeSetValue('#char-unit', data.unit);
    safeSetValue('#char-notes', data.notes);
    safeSetToggle('#char-filter_type', data.filter_type, 'Main');
    safeSetValue('#char-param_type', data.param_type);

    safeSetValue('#char-etalon_id', data.etalon_id);
    safeSetValue('#char-etalon_name', data.etalon_name);
    safeSetValue('#char-etalon_param_type', data.etalon_param_type);
    safeSetValue('#char-etalon_filter_type', data.etalon_filter_type);
    safeSetValue('#char-etalon_unit', data.etalon_unit);
    
    safeSetValue('#char-rztk_id', data.rztk_id);
    safeSetValue('#char-rztk_name', data.rztk_name);
    safeSetValue('#char-rztk_param_type', data.rztk_param_type);
    safeSetValue('#char-rztk_filter_type', data.rztk_filter_type);
    safeSetValue('#char-rztk_unit', data.rztk_unit);

}

function getCharacteristicDataFromForm(modalEl) {
    const getValue = (selector) => modalEl.querySelector(selector)?.value || '';
    const getCheckboxValue = (selector) => modalEl.querySelector(selector)?.checked ? 'TRUE' : 'FALSE';
    const getMultiSelectValue = (selector) => Array.from(modalEl.querySelector(selector)?.selectedOptions || []).map(opt => opt.value).join(',');
    const getToggleValue = (selector, onValue, offValue) => modalEl.querySelector(selector)?.checked ? onValue : offValue;

    const isGlobal = getCheckboxValue('#char-is_global') === 'TRUE';

    return {
        local_id: getValue('#char-local_id'),
        name_uk: getValue('#char-name_uk').trim(),
        name_ru: getValue('#char-name_ru').trim(),
        // (ОНОВЛЕНО) Якщо параметр глобальний, зберігаємо порожній рядок для категорій
        category_local_ids: isGlobal ? '' : getMultiSelectValue('#char-category_local_ids'),
        triggering_option_id: getValue('#char-triggering_option_id'),
        param_type: getValue('#char-param_type'),
        unit: getValue('#char-unit').trim(),
        filter_type: getToggleValue('#char-filter_type', 'Main', 'Disable'),
        is_global: isGlobal ? 'TRUE' : 'FALSE',
        notes: getValue('#char-notes').trim(),
        
        etalon_id: getValue('#char-etalon_id').trim(),
        etalon_name: getValue('#char-etalon_name').trim(),
        etalon_param_type: getValue('#char-etalon_param_type').trim(),
        etalon_filter_type: getValue('#char-etalon_filter_type').trim(),
        etalon_unit: getValue('#char-etalon_unit').trim(),

        rztk_id: getValue('#char-rztk_id').trim(),
        rztk_name: getValue('#char-rztk_name').trim(),
        rztk_param_type: getValue('#char-rztk_param_type').trim(),
        rztk_filter_type: getValue('#char-rztk_filter_type').trim(),
        rztk_unit: getValue('#char-rztk_unit').trim(),

    };
}

function initGlobalParamToggle(modalEl) {
    const isGlobalToggle = modalEl.querySelector('#char-is_global');
    const categoriesSelectEl = modalEl.querySelector('#char-category_local_ids');
    if (!isGlobalToggle || !categoriesSelectEl) return;

    const customSelectWrapper = categoriesSelectEl.closest('.custom-select-wrapper');
    let lastCategorySelection = [];

    const updateState = () => {
        if (isGlobalToggle.checked) {
            // Зберігаємо поточний вибір
            lastCategorySelection = Array.from(categoriesSelectEl.selectedOptions).map(opt => opt.value);
            // Очищуємо вибір
            Array.from(categoriesSelectEl.options).forEach(opt => opt.selected = false);
            // Блокуємо селект
            if (customSelectWrapper) customSelectWrapper.classList.add('disabled');
        } else {
            // Розблоковуємо селект
            if (customSelectWrapper) customSelectWrapper.classList.remove('disabled');
            // Відновлюємо вибір
            Array.from(categoriesSelectEl.options).forEach(opt => {
                if (lastCategorySelection.includes(opt.value)) {
                    opt.selected = true;
                }
            });
        }
        // Оновлюємо відображення кастомного селекту
        if (categoriesSelectEl.customSelect) {
            categoriesSelectEl.customSelect._updateSelection();
        }
    };
    
    // Встановлюємо початковий стан при завантаженні
    if (isGlobalToggle.checked) {
        if (customSelectWrapper) customSelectWrapper.classList.add('disabled');
    }
    
    isGlobalToggle.addEventListener('change', updateState);
}

// ========================================================================
// === OPTION FORM LOGIC (Відновлена логіка) ===
// ========================================================================

async function renderOptionFormContent(modalEl, data) {
    const isEditing = !!data.local_id;
    const titleEl = modalEl.querySelector('#modal-title');
    if (titleEl) titleEl.innerText = isEditing ? `Редагування опції "${data.name_uk || ''}"` : 'Створити опцію';

    await populateParentCharacteristicSelect(modalEl, data.char_local_id);
    populateOptionForm(modalEl, data);

    const parentSelect = modalEl.querySelector('#opt-char_local_id');
    if (parentSelect) reinitializeCustomSelect(parentSelect);
}

async function populateParentCharacteristicSelect(modalEl, selectedId) {
    const select = modalEl.querySelector('#opt-char_local_id');
    if (!select) return;
    select.innerHTML = '';
    const allCharacteristics = await getCharacteristics();
    allCharacteristics.sort((a,b) => (a.name_uk || '').localeCompare(b.name_uk || ''));
    allCharacteristics.forEach(char => {
        const option = new Option(char.name_uk, char.local_id);
        option.selected = (char.local_id === selectedId);
        select.add(option);
    });
}

function populateOptionForm(modalEl, data) {
    const safeSetValue = (selector, value) => {
        const element = modalEl.querySelector(selector);
        if (element) element.value = value || '';
    };

    safeSetValue('#opt-local_id', data.local_id);
    safeSetValue('#opt-name_uk', data.name_uk);
    safeSetValue('#opt-name_ru', data.name_ru);

    // (ВИПРАВЛЕНО) Заповнюємо дані маркетплейсів
    safeSetValue('#opt-etalon_id', data.etalon_id);
    safeSetValue('#opt-etalon_name', data.etalon_name);
    safeSetValue('#opt-rztk_id', data.rztk_id);
    safeSetValue('#opt-rztk_name', data.rztk_name);
}


function getOptionDataFromForm(modalEl) {
    const getValue = (selector) => modalEl.querySelector(selector)?.value || '';
    return {
        local_id: getValue('#opt-local_id'),
        char_local_id: getValue('#opt-char_local_id'),
        name_uk: getValue('#opt-name_uk').trim(),
        name_ru: getValue('#opt-name_ru').trim(),

        // (ВИПРАВЛЕНО) Зчитуємо дані маркетплейсів
        etalon_id: getValue('#opt-etalon_id').trim(),
        etalon_name: getValue('#opt-etalon_name').trim(),
        rztk_id: getValue('#opt-rztk_id').trim(),
        rztk_name: getValue('#opt-rztk_name').trim(),
    };
}


// ========================================================================
// === GENERAL MODAL LOGIC (Загальна логіка модальних вікон) ===
// ========================================================================

async function loadSidePanelsData(modalEl, categoryId) {
    const childrenContainer = modalEl.querySelector('#children-panel .related-content-container');
    const charsContainer = modalEl.querySelector('#characteristics-panel .related-content-container');
    if (childrenContainer) childrenContainer.innerHTML = '<p>Завантаження...</p>';
    if (charsContainer) charsContainer.innerHTML = '<p>Завантаження...</p>';

    const [children, characteristics] = await Promise.all([
        getChildCategories(categoryId),
        getLinkedCharacteristics(categoryId)
    ]);

    const childrenBtn = modalEl.querySelector('#show-children-btn');
    const charsBtn = modalEl.querySelector('#show-chars-btn');

    if (children.length > 0) {
        if (childrenBtn) childrenBtn.style.display = 'block';
        if (childrenContainer) childrenContainer.innerHTML = await generateSidePanelTableHTML('categories', "Дочірні категорії", { name_uk: "Назва" }, children, 'modals/partials/child-category-panel.html');
    } else if (childrenContainer) {
        childrenContainer.innerHTML = '<p style="padding: 16px;">Дочірні категорії відсутні.</p>';
    }

    if (characteristics.length > 0) {
        if (charsBtn) charsBtn.style.display = 'block';
        if (charsContainer) charsContainer.innerHTML = await generateSidePanelTableHTML('characteristics', "Прив'язані характеристики", { name_uk: "Назва" }, characteristics, 'modals/partials/linked-characteristic-panel.html');
    } else if (charsContainer) {
        charsContainer.innerHTML = '<p style="padding: 16px;">Прив\'язані характеристики відсутні.</p>';
    }
}

function initModalLogic(modalEl) {
  modalEl.addEventListener('click', e => { if (e.target === modalEl) closeModal(); });
  modalEl.querySelector('.modal-close-btn')?.addEventListener('click', closeModal);

  modalEl.querySelector('#saveCategoryBtn')?.addEventListener('click', () => handleSaveCategory(modalEl));
  modalEl.querySelector('#saveCharacteristicBtn')?.addEventListener('click', () => handleSaveCharacteristic(modalEl));
  modalEl.querySelector('#saveOptionBtn')?.addEventListener('click', () => handleSaveOption(modalEl));

  modalEl.addEventListener('click', (event) => handleModalClick(event, modalEl));
  modalEl.addEventListener('input', (event) => {
    if (event.target.classList.contains('side-panel-search')) handleSidePanelSearch(event.target);
  });

  // ⬇ ВСТАВИТИ ЦЕЙ БЛОК ТУТ
  modalEl.addEventListener('change', (e) => {
    const target = e.target;
    if (!target.matches('.row-checkbox, .header-select-all')) return;

    const table = target.closest('.pseudo-table');
    if (!table) return;

    const entityType = table.dataset.entityType;     // бічні панелі мають його
    const state = getPaginationState(entityType);
    if (!state) return;

    const body = table.querySelector('.pseudo-table-body');

    if (target.classList.contains('header-select-all')) {
      const cbs = table.querySelectorAll('.row-checkbox');
      cbs.forEach(cb => {
        cb.checked = target.checked;
        const id = cb.dataset.id;
        if (target.checked) state.selectedIds.add(id);
        else state.selectedIds.delete(id);
      });
    } else {
      const id = target.dataset.id;
      if (target.checked) state.selectedIds.add(id);
      else state.selectedIds.delete(id);
    }

    if (body) updateSelectAllState(body);

    const sidePanel = table.closest('.related-section');
    const delBtn = sidePanel?.querySelector('.btn-delete');
    if (delBtn) delBtn.disabled = table.querySelectorAll('.row-checkbox:checked').length === 0;

    e.stopPropagation(); // щоб глобальний слухач на <body> не дублював дію
  });

    
    const childrenBtn = modalEl.querySelector('#show-children-btn');
    const charsBtn = modalEl.querySelector('#show-chars-btn');
    const optionsBtn = modalEl.querySelector('#show-options-btn');
    const childrenPanel = modalEl.querySelector('#children-panel');
    const charsPanel = modalEl.querySelector('#characteristics-panel');
    const optionsPanel = modalEl.querySelector('#options-panel');
    const modalBody = modalEl.querySelector('.modal-body--split');

    const togglePanel = (panelToShow, buttonToActivate) => {
        if (!panelToShow || !buttonToActivate) return;
        const isAlreadyVisible = panelToShow.classList.contains('visible');
        [childrenBtn, charsBtn, optionsBtn].forEach(btn => btn?.classList.remove('active'));
        [childrenPanel, charsPanel, optionsPanel].forEach(panel => panel?.classList.remove('visible'));
        if (isAlreadyVisible) {
            modalBody?.classList.remove('side-panel-visible');
        } else {
            panelToShow.classList.add('visible');
            buttonToActivate.classList.add('active');
            modalBody?.classList.add('side-panel-visible');
        }
    };
    if (childrenBtn) childrenBtn.addEventListener('click', () => togglePanel(childrenPanel, childrenBtn));
    if (charsBtn) charsBtn.addEventListener('click', () => togglePanel(charsPanel, charsBtn));
    if (optionsBtn) optionsBtn.addEventListener('click', () => togglePanel(optionsPanel, optionsBtn));
}

async function handleSaveCategory(modalEl) {
    const formData = getCategoryDataFromForm(modalEl);
    if (!formData.name_uk) {
        showToast('Назва (укр) є обов\'язковим полем!', 'error');
        return;
    }
    const result = await saveCategory(formData);
    if (result.status === 'success') {
        showToast('Категорію успішно збережено!', 'success');
        document.dispatchEvent(new CustomEvent('dataChanged', { detail: { entityType: 'categories' } }));
        if (modalHistory.length > 1) {
             modalHistory.pop();
             await renderCategoryFormContent(modalEl.querySelector('.modal-content'), modalHistory[modalHistory.length - 1]);
        } else {
            closeModal();
        }
    } else {
        showToast(result.message || 'Помилка при збереженні.', 'error');
    }
}

async function handleSaveCharacteristic(modalEl) {
    const formData = getCharacteristicDataFromForm(modalEl);
    if (!formData.name_uk) {
        showToast('Назва (укр) є обов\'язковим полем!', 'error');
        return;
    }
    const result = await saveCharacteristic(formData);
    if (result.status === 'success') {
        showToast('Характеристику успішно збережено!', 'success');
        document.dispatchEvent(new CustomEvent('dataChanged', { detail: { entityType: 'characteristics' } }));
        closeModal();
    } else {
        showToast(result.message || 'Помилка при збереженні.', 'error');
    }
}

async function handleSaveOption(modalEl) {
    const formData = getOptionDataFromForm(modalEl);
    if (!formData.name_uk || !formData.char_local_id) {
        showToast('Обидва поля є обов\'язковими!', 'error');
        return;
    }
    const result = await saveOption(formData);
    if (result.status === 'success') {
        showToast('Опцію успішно збережено!', 'success');
        document.dispatchEvent(new CustomEvent('dataChanged', { detail: { entityType: 'options' } }));
        // Оскільки опції редагуються з вікна характеристики, треба оновити і її
        document.dispatchEvent(new CustomEvent('dataChanged', { detail: { entityType: 'characteristics' } }));
        closeModal();
    } else {
        showToast(result.message || 'Помилка при збереженні.', 'error');
    }
}


async function handleModalClick(event, modalEl) {
    const target = event.target.closest('button');
    if (!target) return;
    const contentEl = modalEl.querySelector('.modal-content');
    const formType = contentEl.dataset.formType;

    if (target.id === 'modal-back-btn' && formType === 'category-form' && modalHistory.length > 1) {
        modalHistory.pop();
        await renderCategoryFormContent(contentEl, modalHistory[modalHistory.length - 1]);
        return;
    }

    let entityId = target.dataset.id;
    if (!entityId) return;
    
    let entityToEdit = null;
    let nextModalName = null;

    try {
        if (target.classList.contains('btn-edit-child-category')) {
            entityToEdit = await getCategoryById(entityId, true);
        } else if (target.classList.contains('btn-edit-char')) {
            entityToEdit = await getCharacteristicById(entityId, true); 
            nextModalName = 'characteristic-form';
        } else if (target.classList.contains('btn-edit-option')) {
            entityToEdit = await getOptionById(entityId, true); 
            nextModalName = 'option-form';
        }

        if (entityToEdit) {
            if (nextModalName) {
                // Закриваємо поточне вікно і відкриваємо нове
                closeModal(); 
                loadAndShowModal(nextModalName, entityToEdit);
            } else if (formType === 'category-form') {
                // Перехід до дочірньої категорії всередині одного вікна
                modalHistory.push(entityToEdit);
                await renderCategoryFormContent(contentEl, entityToEdit);
            }
        } else {
             showToast('Запис не знайдено.', 'error');
        }
    } catch(e) {
        showToast('Помилка завантаження даних.', 'error');
    }
}

// Уніфікований пошук у бічній панелі
function handleSidePanelSearch(searchInput) {
    const query = searchInput.value.toLowerCase().trim();
    const tableId = searchInput.dataset.tableTargetId;
    const table = document.getElementById(tableId);
    if (!table) return;

    const sourceData = sidePanelDataSources[tableId];
    if (!sourceData) return;

    const filteredData = sourceData.filter(row => (row.name_uk || '').toLowerCase().includes(query));

    const body = table.querySelector('.pseudo-table-body');
    const entityType = table.dataset.entityType;
    
    body.innerHTML = renderSidePanelRows(entityType, { name_uk: "Назва" }, filteredData);
}

// Рендерить тільки рядки
function renderSidePanelRows(entityType, headers, dataRows) {
     let editButtonClass;
        switch (entityType) {
            case 'child-category': editButtonClass = 'btn-edit-child-category'; break;
            case 'char': editButtonClass = 'btn-edit-char'; break;
            case 'option': editButtonClass = 'btn-edit-option'; break;
            default: editButtonClass = `btn-edit-${entityType}`;
        }
    return dataRows.map(row => {
        const cellsHtml = Object.keys(headers).map(key => `<div class="pseudo-table-cell cell-main-name" data-tooltip="${row[key] || ''}">${row[key] || '—'}</div>`).join('');
        return `<div class="pseudo-table-row-inner" data-id="${row.local_id}">
                    <div class="pseudo-table-cell cell-actions">
                        <input type="checkbox" class="row-checkbox" data-id="${row.local_id}">
                        <button class="${editButtonClass}" data-id="${row.local_id}" title="Редагувати">✎</button>
                    </div>
                    ${cellsHtml}
                </div>`;
    }).join('');
}

async function generateSidePanelTableHTML(entityType, title, headers, dataRows, templatePath) {
    try {
        const response = await fetch(templatePath);
        if (!response.ok) throw new Error(`Шаблон не знайдено: ${templatePath}`);
        let template = await response.text();
        const headerHtml = Object.keys(headers).map(key => `<div class="pseudo-table-cell cell-main-name sortable-header" data-sort-key="${key}"><span>${headers[key]}</span><span class="sort-indicator"></span></div>`).join('');
        const rowsHtml = renderSidePanelRows(entityType, headers, dataRows);
        const tableId = `side-table-${entityType}-${Date.now()}`;

        sidePanelDataSources[tableId] = dataRows;

        template = template.replace('{{TITLE}}', title).replace(/{{TABLE_ID}}/g, tableId).replace('{{HEADER_CELLS}}', headerHtml).replace('{{BODY_ROWS}}', rowsHtml);

        const tempDiv = document.createElement('div');
        tempDiv.innerHTML = template;
        const tableEl = tempDiv.querySelector('.pseudo-table');
        if (tableEl) tableEl.dataset.entityType = entityType;
        return tempDiv.innerHTML;
    } catch (error) {
        console.error('Помилка при генерації таблиці:', error);
        return '<p style="color: red;">Помилка.</p>';
    }
}
// scripts/components/modal_init.js
import { loadAndShowModal } from './modal.js';
import { initImportModal } from '../actions/import_ui.js'; // Змінено шлях

export function initModalButtons() {
    document.body.addEventListener('click', async (event) => {
        const addButton = event.target.closest('.btn-add');
        if (addButton) {
            const currentTab = document.querySelector('.tab-content.active');
            if (!currentTab) return;

            switch (currentTab.id) {
                case 'categories':
                    loadAndShowModal('category-form');
                    break;
                case 'characteristics':
                    loadAndShowModal('characteristic-form');
                    break;
                case 'options':
                    loadAndShowModal('option-form');
                    break;
            }
        }
        
        if (event.target.id === 'importBtn' || event.target.closest('#importBtn')) {
            await loadAndShowModal('import-form');
            await initImportModal();
        }
    });
}
// scripts/components/select.js (ПОВНА ОНОВЛЕНА ВЕРСІЯ З ResizeObserver)

export function initCustomSelects() {
    document.querySelectorAll('select[data-custom-select]').forEach(selectEl => {
        if (!selectEl.closest('.custom-select-wrapper')) {
            new CustomSelect(selectEl);
        }
    });
}

export function reinitializeCustomSelect(selectElement) {
    if (!selectElement) return;
    const existingWrapper = selectElement.closest('.custom-select-wrapper');
    if (existingWrapper) {
        // (НОВЕ) Зупиняємо спостерігач перед видаленням, щоб уникнути витоків пам'яті
        if (selectElement.customSelect && selectElement.customSelect.observer) {
            selectElement.customSelect.observer.disconnect();
        }
        existingWrapper.parentNode.insertBefore(selectElement, existingWrapper);
        existingWrapper.remove();
        selectElement.style.display = '';
    }
    new CustomSelect(selectElement);
}

class CustomSelect {
    constructor(originalSelect) {
        this.originalSelect = originalSelect;
        this.originalSelect.customSelect = this;
        this.isMultiSelect = originalSelect.multiple;
        
        this._buildDOM();
        this._populateOptions();
        
        // (НОВЕ) Ініціалізуємо ResizeObserver для динамічного відстеження розміру
        this.observer = new ResizeObserver(() => {
            // Викликаємо оновлення відображення при кожній зміні розміру
            this._updateSelection();
        });
        this.observer.observe(this.trigger); // Починаємо стежити за полем вибору

        this._updateSelection(); 
        this._bindEvents();
    }

    _buildDOM() {
        this.wrapper = this._createElement('div', { class: 'custom-select-wrapper' });
        this.trigger = this._createElement('div', { class: 'custom-select-trigger' });
        this.valueContainer = this._createElement('div', { class: 'custom-select-value-container' });
        this.arrow = this._createArrowSVG();
        this.panel = this._createElement('div', { class: 'custom-select-panel' });
        
        // (НОВЕ) Контейнер для чіпів при переповненні
        this.overflowChipContainer = this._createElement('div', { class: 'custom-select-overflow-chips' });

        this.optionsList = this._createElement('ul', { class: 'custom-select-options', role: 'listbox' });

        this.originalSelect.style.display = 'none';
        this.originalSelect.parentNode.insertBefore(this.wrapper, this.originalSelect);
        
        this.trigger.appendChild(this.valueContainer);
        this.trigger.appendChild(this.arrow);
        this.wrapper.appendChild(this.trigger);
        this.wrapper.appendChild(this.panel);
        this.wrapper.appendChild(this.originalSelect);

        this.panel.appendChild(this.overflowChipContainer); // Додаємо новий контейнер

        if (Array.from(this.originalSelect.options).length > 5) {
            const searchWrapper = this._createElement('div', { class: 'custom-select-search-wrapper' });
            this.searchInput = this._createElement('input', { type: 'text', class: 'custom-select-search', placeholder: 'Пошук...' });
            searchWrapper.appendChild(this.searchInput);
            this.panel.appendChild(searchWrapper);
        }
        
        this.panel.appendChild(this.optionsList);
    }

    _populateOptions() {
        this.optionsList.innerHTML = '';
        Array.from(this.originalSelect.options).forEach(option => {
            if (!option.value && this.isMultiSelect) return; // Пропускаємо порожні опції в мультиселекті

            const optionEl = this._createElement('li', {
                class: 'custom-select-option',
                'data-value': option.value,
                role: 'option'
            });
            optionEl.innerHTML = option.dataset.htmlContent || option.textContent;
            this.optionsList.appendChild(optionEl);
        });
    }

    /**
     * (ПОВНІСТЮ ПЕРЕПИСАНО) Оновлює видиму частину і панель чіпів.
     */
    _updateSelection() {
        const selectedOptions = Array.from(this.originalSelect.options).filter(opt => opt.selected && opt.value);
        
        // Оновлюємо стан is-selected для списку
        this.optionsList.querySelectorAll('.custom-select-option').forEach(customOpt => {
            const isSelected = selectedOptions.some(selOpt => selOpt.value === customOpt.dataset.value);
            customOpt.classList.toggle('is-selected', isSelected);
        });

        if (!this.isMultiSelect) {
            this.valueContainer.innerHTML = selectedOptions.length > 0
                ? (selectedOptions[0].dataset.htmlContent || selectedOptions[0].textContent)
                : `<span class="custom-select-placeholder">${this.originalSelect.placeholder || 'Виберіть...'}</span>`;
            return;
        }

        // Логіка для мультиселекту
        this.valueContainer.innerHTML = '';
        this.overflowChipContainer.innerHTML = '';
        this.overflowChipContainer.style.display = 'none';

        if (selectedOptions.length === 0) {
            this.valueContainer.innerHTML = `<span class="custom-select-placeholder">${this.originalSelect.placeholder || 'Виберіть...'}</span>`;
            return;
        }
        
        const chips = selectedOptions.map(option => this._createChip(option));
        
        // Перевірка на переповнення
        chips.forEach(chip => this.valueContainer.appendChild(chip));
        const isOverflowing = this.valueContainer.scrollHeight > this.valueContainer.clientHeight;
        
        if (isOverflowing) {
            this.valueContainer.innerHTML = '';
            const summaryChip = this._createElement('div', { class: 'custom-select-chip is-summary' });
            summaryChip.textContent = selectedOptions.length;
            this.valueContainer.appendChild(summaryChip);

            chips.forEach(chip => this.overflowChipContainer.appendChild(chip));
            this.overflowChipContainer.style.display = 'flex';
        }
    }
    _createChip(option) {
        const chip = this._createElement('div', { class: 'custom-select-chip' });
        
        // (ОНОВЛЕНО) Нова логіка відображення чіпа
        const shortName = option.dataset.name;
        const level = parseInt(option.dataset.level, 10);
        if (shortName && !isNaN(level)) {
            const prefix = ' / '.repeat(level);
            chip.textContent = `${prefix}${shortName}`.trim();
        } else {
            chip.textContent = option.textContent;
        }
        
        const removeBtn = this._createElement('button', { type: 'button', class: 'custom-select-chip__remove' });
        removeBtn.innerHTML = '&times;';
        
        removeBtn.addEventListener('click', (e) => {
            e.stopPropagation();
            const correspondingOption = Array.from(this.originalSelect.options).find(opt => opt.value === option.value);
            if(correspondingOption) correspondingOption.selected = false;
            this.originalSelect.dispatchEvent(new Event('change', { bubbles: true }));
            this._updateSelection();
        });

        chip.appendChild(removeBtn);
        return chip;
    }

    _bindEvents() {
        this.trigger.addEventListener('click', () => this.wrapper.classList.toggle('is-open'));

        this.optionsList.addEventListener('click', (e) => {
            const optionEl = e.target.closest('.custom-select-option');
            if (optionEl && 'value' in optionEl.dataset) {
                const option = Array.from(this.originalSelect.options).find(opt => opt.value === optionEl.dataset.value);
                if (this.isMultiSelect) {
                    option.selected = !option.selected;
                } else {
                    this.originalSelect.value = option.value;
                    this.wrapper.classList.remove('is-open');
                }
                this.originalSelect.dispatchEvent(new Event('change', { bubbles: true }));
                this._updateSelection();
            }
        });

        document.addEventListener('click', (e) => {
            if (!this.wrapper.contains(e.target)) this.wrapper.classList.remove('is-open');
        });

        if (this.searchInput) {
            this.searchInput.addEventListener('input', (e) => {
                const query = e.target.value.toLowerCase();
                this.optionsList.querySelectorAll('.custom-select-option').forEach(optEl => {
                    const text = optEl.textContent.toLowerCase();
                    optEl.style.display = text.includes(query) ? '' : 'none';
                });
            });
        }
    }
    /**
     * Фільтрує опції у випадаючому списку на основі пошукового запиту.
     */
    _filterOptions(query) {
        const lowerCaseQuery = query.toLowerCase();
        this.optionsList.querySelectorAll('.custom-select-option').forEach(optEl => {
            const text = optEl.textContent.toLowerCase();
            optEl.classList.toggle('is-hidden', !text.includes(lowerCaseQuery));
        });
    }

    _toggleDropdown() { this.wrapper.classList.toggle('is-open'); }
    _closeDropdown() { this.wrapper.classList.remove('is-open'); }
    _dispatchChangeEvent() { this.originalSelect.dispatchEvent(new Event('change', { bubbles: true })); }
    
    _createArrowSVG() {
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'custom-select-arrow');
        svg.setAttribute('viewBox', '0 0 24 24');
        const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        path.setAttribute('d', 'M7 10l5 5 5-5z');
        svg.appendChild(path);
        return svg;
    }
    
    _createElement(tag, attributes = {}) {
        const element = document.createElement(tag);
        for (const [key, value] of Object.entries(attributes)) {
            element.setAttribute(key, value);
        }
        return element;
    }
}
// scripts/actions/selection.js (ПОВНА ОНОВЛЕНА ВЕРСІЯ)

import { getPaginationState } from '../components/table.js';

// (НОВЕ) Функції для доступу до стану виділення
export function getSelectedIds(entityType) {
    const state = getPaginationState(entityType);
    return state ? state.selectedIds : new Set();
}

export function isSelected(entityType, id) {
    const selectedIds = getSelectedIds(entityType);
    return selectedIds.has(id);
}

function toggleSelection(entityType, id) {
    const selectedIds = getSelectedIds(entityType);
    if (selectedIds.has(id)) {
        selectedIds.delete(id);
    } else {
        selectedIds.add(id);
    }
}

function selectAllVisible(entityType, table, shouldSelect) {
    const selectedIds = getSelectedIds(entityType);
    const visibleCheckboxes = table.querySelectorAll('.pseudo-table-row:not([style*="display: none"]) .row-checkbox, .pseudo-table-row-inner:not([style*="display: none"]) .row-checkbox');

    visibleCheckboxes.forEach(checkbox => {
        const id = checkbox.dataset.id;
        if (shouldSelect) {
            selectedIds.add(id);
        } else {
            selectedIds.delete(id);
        }
        checkbox.checked = shouldSelect;
    });
}

// scripts/actions/selection.js
export function initSelection() {
  const rootElement = document.body;

  rootElement.addEventListener('change', (event) => {
    const target = event.target;
    const table = target.closest('.pseudo-table');
    if (!table) return;

    // ВАЖЛИВО: універсальне визначення типу сутності
    let entityType = target.closest('.tab-content')?.id;
    if (!entityType) entityType = table.dataset.entityType;  // <— цей фолбек обов’язковий

    if (!entityType) return;

    if (target.classList.contains('header-select-all')) {
      selectAllVisible(entityType, table, target.checked);
      updateActionButtonsState(table);
    }

    const rowCheckbox = target.closest('.row-checkbox');
    if (rowCheckbox) {
      const id = rowCheckbox.dataset.id;
      const tableBody = rowCheckbox.closest('.pseudo-table-body');
      if (tableBody && id) {
        toggleSelection(entityType, id);
        updateSelectAllState(tableBody);
        updateActionButtonsState(table);
      }
    }
  });
}

/**
 * Обробляє клік на чекбокс "вибрати все", працює з обома типами таблиць.
 */
function handleSelectAll(headerCheckbox) {
    const table = headerCheckbox.closest('.pseudo-table');
    if (!table) return;

    // Шукаємо рядки обох типів: і в основній таблиці, і в бічній панелі
    const allRows = table.querySelectorAll('.pseudo-table-row, .pseudo-table-row-inner');
    const visibleRows = Array.from(allRows).filter(row => row.style.display !== 'none');

    visibleRows.forEach(row => {
        const checkbox = row.querySelector('.row-checkbox');
        if (checkbox) {
            checkbox.checked = headerCheckbox.checked;
        }
    });
}

/**
 * (ОНОВЛЕНО) Оновлює стан головного чекбоксу, працює з обома типами таблиць.
 */
export function updateSelectAllState(tableBody) {
    if (!tableBody) return;
    const table = tableBody.closest('.pseudo-table');
    const headerCheckbox = table.querySelector('.header-select-all');
    if (!headerCheckbox) return;

    // Шукаємо чекбокси в рядках обох типів
    const allCheckboxes = table.querySelectorAll('.pseudo-table-row .row-checkbox, .pseudo-table-row-inner .row-checkbox');
    const visibleCheckboxes = Array.from(allCheckboxes).filter(cb => cb.closest('.pseudo-table-row, .pseudo-table-row-inner').style.display !== 'none');

    const checkedVisibleCheckboxes = visibleCheckboxes.filter(cb => cb.checked);

    if (visibleCheckboxes.length > 0 && visibleCheckboxes.length === checkedVisibleCheckboxes.length) {
        headerCheckbox.checked = true;
        headerCheckbox.indeterminate = false;
    } else if (checkedVisibleCheckboxes.length > 0) {
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = true;
    } else {
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = false;
    }
}

export function resetSelection(tableElement) {
    if (!tableElement) return;
    const headerCheckbox = tableElement.querySelector('.header-select-all');
    if (headerCheckbox) {
        headerCheckbox.checked = false;
        headerCheckbox.indeterminate = false;
    }
}

/**
 * (НОВА ФУНКЦІЯ)
 * Оновлює стан кнопок дій (напр. "Видалити") на основі кількості виділених рядків.
 * @param {HTMLElement} tableContext - Елемент таблиці або її тіло.
 */
function updateActionButtonsState(tableContext) {
    if (!tableContext) {
        console.error("updateActionButtonsState: tableContext порожній.");
        return;
    }

    const checkedCount = tableContext.querySelectorAll('.row-checkbox:checked').length;
    console.log(`Кількість вибраних: ${checkedCount}`);

    const sidePanel = tableContext.closest('.related-section');
    console.log("Знайдено бічну панель (sidePanel):", sidePanel);

    let deleteButton;

    if (sidePanel) {
        console.log("Шукаю кнопку .btn-delete всередині бічної панелі...");
        deleteButton = sidePanel.querySelector('.btn-delete');
    } else {
        console.log("Бічну панель не знайдено, шукаю кнопку в футері...");
        deleteButton = document.querySelector('footer .btn-delete');
    }

    console.log("Знайдено кнопку видалення (deleteButton):", deleteButton);

    if (deleteButton) {
        deleteButton.disabled = (checkedCount === 0);
        console.log(`Стан кнопки оновлено. disabled = ${deleteButton.disabled}`);
    } else {
        console.error("Кнопку .btn-delete НЕ ЗНАЙДЕНО!");
    }
}
// scripts/components/table.js (ПОВНА УНІФІКОВАНА ВЕРСІЯ)

import { getCategories, getCharacteristics, getOptions, getCategoryById, getCharacteristicById, getOptionById } from '../api/googleSheetService.js';
import { loadAndShowModal } from './modal.js';
import { showToast } from '../features/toast.js';
import { updatePaginationUI } from '../features/pagination.js';
import { updateSortUI } from '../features/sorting.js';
import { getSelectedIds, isSelected } from '../actions/selection.js';

let state = {
    categories: {
        sourceData: [], filteredData: [], currentPage: 1, pageSize: 10,
        sortKey: 'local_id', sortOrder: 'asc', selectedIds: new Set(),
    },
    characteristics: {
        sourceData: [], filteredData: [], currentPage: 1, pageSize: 10,
        sortKey: 'local_id', sortOrder: 'asc', selectedIds: new Set(),
    },
    options: {
        sourceData: [], filteredData: [], currentPage: 1, pageSize: 10,
        sortKey: 'local_id', sortOrder: 'asc', selectedIds: new Set(),
    }
};

export const getPaginationState = (entityType) => state[entityType];
export const updatePaginationState = (entityType, newState) => {
    if (state[entityType]) {
        state[entityType] = { ...state[entityType], ...newState };
    }
};
export const setFilteredData = (entityType, data) => {
    if (state[entityType]) {
        state[entityType].filteredData = data;
        state[entityType].currentPage = 1;
    }
};

/**
 * (НОВА ФУНКЦІЯ) Очищує активну таблицю, наприклад, при виході з системи.
 */
export function clearActiveTable() {
    const activeTab = document.querySelector('.tab-content.active');
    if (!activeTab) return;
    const tableBody = activeTab.querySelector('.pseudo-table-body');
    if (tableBody) {
        tableBody.innerHTML = '<p style="padding: 16px;">Для роботи з даними необхідно авторизуватися.</p>';
    }
    updateCounters(activeTab.id, 0, 0);
}

// ... (CORE LOGIC & EVENT HANDLERS без змін) ...
export function renderActiveTable() {
    const activeTab = document.querySelector('.tab-content.active');
    if (!activeTab) return;
    switch (activeTab.id) {
        case 'categories': renderCategoriesTable(false); break;
        case 'characteristics': renderCharacteristicsTable(false); break;
        case 'options': renderOptionsTable(false); break;
    }
}
function dispatchRenderComplete(entityType) {
    const event = new CustomEvent('renderComplete', { detail: { entityType } });
    document.dispatchEvent(event);
}
function updateCounters(entityType, pageCount, totalCount) {
    const pageCounterEl = document.getElementById(`${entityType}-counter-page`);
    const totalCounterEl = document.getElementById(`${entityType}-counter-all`);
    if (pageCounterEl) pageCounterEl.textContent = pageCount;
    if (totalCounterEl) totalCounterEl.textContent = (totalCount !== undefined) ? totalCount : state[entityType]?.filteredData?.length || 0;
}
export function initTableInteractions() {
    document.addEventListener('dataChanged', handleDataChange);
    document.querySelector('.tabs-container')?.addEventListener('click', handleTableClick);
}
async function handleDataChange(event) {
    const { entityType } = event.detail;
    switch (entityType) {
        case 'categories': await renderCategoriesTable(true); break;
        case 'characteristics': await renderCharacteristicsTable(true); break;
        case 'options': await renderOptionsTable(true); break;
    }
}
async function handleTableClick(event) {
    const editButton = event.target.closest('.btn-edit');
    if (!editButton) return;
    const tabId = editButton.closest('.tab-content')?.id;
    const entityId = editButton.dataset.id;
    if (!tabId || !entityId) return;
    editButton.disabled = true;
    try {
        let data, modalName;
        switch (tabId) {
            case 'categories':
                data = await getCategoryById(entityId);
                modalName = 'category-form';
                break;
            case 'characteristics':
                data = await getCharacteristicById(entityId);
                modalName = 'characteristic-form';
                break;
            case 'options':
                data = await getOptionById(entityId);
                modalName = 'option-form';
                break;
        }
        if (data && modalName) {
            await loadAndShowModal(modalName, data);
        } else {
            showToast("Дані не знайдено або невідомий тип вкладки.", 'error');
        }
    } catch (error) {
        console.error("Помилка завантаження даних для редагування:", error);
        showToast("Помилка завантаження даних.", 'error');
    } finally {
        if (document.body.contains(editButton)) {
           editButton.disabled = false;
        }
    }
}


// ========================================================================
// === RENDER FUNCTIONS (Функції рендерингу) ===
// ========================================================================

export async function renderCategoriesTable(forceReload = false) {
    const entityType = 'categories';
    const tableBody = document.querySelector(`#${entityType} .pseudo-table-body`);
    if (!tableBody) return;

    try {
        if (forceReload || state[entityType].sourceData.length === 0) {
            tableBody.innerHTML = '<p style="padding: 16px;">Завантаження...</p>';
            // (ВИПРАВЛЕНО) Одночасно завантажуємо і категорії, і характеристики для підрахунку
            const [categoriesData, characteristicsData] = await Promise.all([
                getCategories(),
                getCharacteristics()
            ]);
            const processedData = processCategoriesData(categoriesData, characteristicsData);
            updatePaginationState(entityType, { sourceData: processedData, filteredData: processedData });
        }
        // ... (решта логіки рендерингу без змін) ...
        const currentState = getPaginationState(entityType);
        let { filteredData, currentPage, pageSize, sortKey, sortOrder } = currentState;
        if (sortKey) {
            filteredData = [...filteredData].sort((a, b) => {
                const valA = a[sortKey] === undefined ? '' : a[sortKey];
                const valB = b[sortKey] === undefined ? '' : b[sortKey];
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return sortOrder === 'asc' ? valA - valB : valB - valA;
                }
                return sortOrder === 'asc' ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
            });
        }
        const startIndex = (currentPage - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const pageData = filteredData.slice(startIndex, endIndex);
        if (pageData.length === 0) {
            tableBody.innerHTML = filteredData.length > 0 ? `<p style="padding: 16px;">Немає результатів на цій сторінці.</p>` : `<p style="padding: 16px;">Дані відсутні.</p>`;
        } else {
            tableBody.innerHTML = pageData.map(category => {
                const isChecked = isSelected('categories', category.local_id); // (ОНОВЛЕНО)
                const nameDisplay = category.name_uk || 'Без назви';
                const charCount = category.charCount || 0;
                 return `
                    <div class="pseudo-table-row" data-id="${category.local_id}">
                        <div class="pseudo-table-cell cell-actions">
                            <input type="checkbox" class="row-checkbox" data-id="${category.local_id}" ${isChecked ? 'checked' : ''}>
                            <button class="btn-edit" data-id="${category.local_id}" title="Редагувати">✎</button>
                        </div>

                        <div class="pseudo-table-cell cell-id" data-tooltip="${category.local_id}">${category.local_id}</div>
                        <div class="pseudo-table-cell cell-level">${category.level || 0}</div>
                        <div class="pseudo-table-cell" data-tooltip="${nameDisplay}">${nameDisplay}</div>
                        <div class="pseudo-table-cell" data-tooltip="${category.etalon_name}">${category.etalon_name || '—'}</div>
                        <div class="pseudo-table-cell" data-tooltip="${category.rztk_name}">${category.rztk_name || '—'}</div>
                        <div class="pseudo-table-cell" data-tooltip="${category.epicenter_name}">${category.epicenter_name || '—'}</div>
                        <div class="pseudo-table-cell" data-tooltip="${category.allo_name}">${category.allo_name || '—'}</div>
                        <div class="pseudo-table-cell" data-tooltip="${category.fua_name}">${category.fua_name || '—'}</div>
                        <div class="pseudo-table-cell" data-tooltip="${category.maudau_name}">${category.maudau_name || '—'}</div>
                        <div class="pseudo-table-cell cell-count">${charCount}</div>
                    </div>
                `;
            }).join('');
        }
        updateCounters(entityType, pageData.length, filteredData.length);
        updatePaginationUI(entityType, filteredData.length);
        updateSortUI(entityType);
    } catch (error) {
        console.error(`Помилка рендерингу ${entityType}:`, error);
        tableBody.innerHTML = `<p style="padding: 16px; color: red;">Помилка: ${error.message}</p>`;
    } finally {
        dispatchRenderComplete(entityType);
    }
}
// ... (renderCharacteristicsTable, renderOptionsTable без змін) ...
export async function renderCharacteristicsTable(forceReload = false) {
    const entityType = 'characteristics';
    const tableBody = document.querySelector(`#${entityType} .pseudo-table-body`);
    if (!tableBody) return;
    try {
        if (forceReload || state[entityType].sourceData.length === 0) {
            tableBody.innerHTML = '<p style="padding: 16px;">Завантаження...</p>';
            // 1. ЗАВАНТАЖУЄМО ОПЦІЇ РАЗОМ З ІНШИМИ ДАНИМИ
            const [charData, catData, optData] = await Promise.all([
                getCharacteristics(), 
                getCategories(),
                getOptions() // Додано завантаження опцій
            ]);
            // 2. СТВОРЮЄМО МАПУ ДЛЯ ШВИДКОГО ПІДРАХУНКУ ОПЦІЙ
            const optionCountMap = new Map();
            optData.forEach(opt => {
                const charId = opt.char_local_id;
                if (charId) {
                    optionCountMap.set(charId, (optionCountMap.get(charId) || 0) + 1);
                }
            });

            const categoryMap = new Map(catData.map(cat => [cat.local_id, cat.name_uk]));
            // 3. ДОДАЄМО КІЛЬКІСТЬ ОПЦІЙ (`optionCount`) ДО КОЖНОГО ОБ'ЄКТА ХАРАКТЕРИСТИКИ
            const processedData = charData.map(char => ({
                ...char,
                linkedCategoryNames: (char.category_local_ids || '')
                    .split(',')
                    .map(id => categoryMap.get(id.trim()))
                    .filter(Boolean)
                    .join(', '),
                optionCount: optionCountMap.get(char.local_id) || 0 // Додаємо нову властивість
            }));
            updatePaginationState(entityType, { sourceData: processedData, filteredData: processedData });
        }
        const currentState = getPaginationState(entityType);
        let { filteredData, currentPage, pageSize, sortKey, sortOrder } = currentState;
        if (sortKey) {
            filteredData = [...filteredData].sort((a, b) => {
                const valA = a[sortKey] === undefined ? '' : a[sortKey];
                const valB = b[sortKey] === undefined ? '' : b[sortKey];
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return sortOrder === 'asc' ? valA - valB : valB - valA;
                }
                return sortOrder === 'asc' ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
            });
        }
        const startIndex = (currentPage - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const pageData = filteredData.slice(startIndex, endIndex);
        if (pageData.length === 0) {
            tableBody.innerHTML = filteredData.length > 0 ? `<p style="padding: 16px;">Немає результатів на цій сторінці.</p>` : `<p style="padding: 16px;">Дані відсутні.</p>`;
        } else {
            tableBody.innerHTML = pageData.map(char => {
                const isChecked = isSelected('characteristics', char.local_id);
                return `
                    <div class="pseudo-table-row" data-id="${char.local_id}">
                        <div class="pseudo-table-cell cell-actions">
                            <input type="checkbox" class="row-checkbox" data-id="${char.local_id}" ${isChecked ? 'checked' : ''}>
                            <button class="btn-edit" data-id="${char.local_id}" title="Редагувати">✎</button>
                        </div>
                        <div class="pseudo-table-cell cell-id" data-tooltip="${char.local_id}">${char.local_id}</div>
                        <div class="pseudo-table-cell cell-linked-cats" data-tooltip="${char.linkedCategoryNames}">${char.linkedCategoryNames || 'Глобальна'}</div>
                        <div class="pseudo-table-cell" data-tooltip="${char.name_uk}">${char.name_uk || '—'}</div>
                        <div class="pseudo-table-cell" data-tooltip="${char.etalon_name}">${char.etalon_name || '—'}</div>
                        <div class="pseudo-table-cell" data-tooltip="${char.rztk_name}">${char.rztk_name || '—'}</div>
                        <div class="pseudo-table-cell cell-bool">${char.is_global === 'TRUE' ? 'Так' : 'Ні'}</div>
                        <div class="pseudo-table-cell cell-count">${char.optionCount}</div>
                    </div>
                `;
            }).join('');
        }
        updateCounters(entityType, pageData.length, filteredData.length);
        updatePaginationUI(entityType, filteredData.length);
        updateSortUI(entityType);
    } catch (error) {
        console.error(`Помилка рендерингу ${entityType}:`, error);
        tableBody.innerHTML = `<p style="padding: 16px; color: red;">Помилка: ${error.message}</p>`;
    } finally {
        dispatchRenderComplete(entityType);
    }
}

export async function renderOptionsTable(forceReload = false) {
    const entityType = 'options';
    const tableBody = document.querySelector(`#${entityType} .pseudo-table-body`);
    if (!tableBody) return;

    try {
        if (forceReload || state[entityType].sourceData.length === 0) {
            tableBody.innerHTML = '<p style="padding: 16px;">Завантаження...</p>';
            const [optData, charData, catData] = await Promise.all([getOptions(), getCharacteristics(), getCategories()]);
            const categoryMap = new Map(catData.map(cat => [cat.local_id, cat.name_uk]));
            
            // Тепер charMap зберігає ВЕСЬ об'єкт характеристики, а не тільки ім'я
            const charMap = new Map(charData.map(char => [char.local_id, char]));

            const processedData = optData.map(opt => {
                const parentChar = charMap.get(opt.char_local_id);
                let categoryNames = '—';

                // Якщо батьківська характеристика знайдена і вона не глобальна
                if (parentChar && parentChar.is_global !== 'TRUE' && parentChar.category_local_ids) {
                    categoryNames = parentChar.category_local_ids
                        .split(',')
                        .map(id => categoryMap.get(id.trim()))
                        .filter(Boolean) // Видаляємо порожні значення
                        .join(', ');
                } else if (parentChar && parentChar.is_global === 'TRUE') {
                    categoryNames = 'Глобальна';
                }

                return {
                    ...opt,
                    parentCharacteristicName: parentChar ? parentChar.name_uk : 'Невідомо',
                    parentCharacteristicCategoryNames: categoryNames
                };
            });
            updatePaginationState(entityType, { sourceData: processedData, filteredData: processedData });
        }

        const currentState = getPaginationState(entityType);
        let { filteredData, currentPage, pageSize, sortKey, sortOrder } = currentState;
        
        if (sortKey) {
             filteredData = [...filteredData].sort((a,b) => {
                const valA = a[sortKey] === undefined ? '' : a[sortKey];
                const valB = b[sortKey] === undefined ? '' : b[sortKey];
                if (typeof valA === 'number' && typeof valB === 'number') {
                    return sortOrder === 'asc' ? valA - valB : valB - valA;
                }
                return sortOrder === 'asc' ? String(valA).localeCompare(String(valB)) : String(valB).localeCompare(String(valA));
             }); 
        }

        const startIndex = (currentPage - 1) * pageSize;
        const endIndex = startIndex + pageSize;
        const pageData = filteredData.slice(startIndex, endIndex);

        if (pageData.length === 0) {
            tableBody.innerHTML = filteredData.length > 0 ? `<p style="padding: 16px;">Немає результатів на цій сторінці.</p>` : `<p style="padding: 16px;">Дані відсутні.</p>`;
        } else {
                        tableBody.innerHTML = pageData.map(opt => {
                const isChecked = isSelected('options', opt.local_id);
                return `
                <div class="pseudo-table-row" data-id="${opt.local_id}">
                    <div class="pseudo-table-cell cell-actions">
                        <input type="checkbox" class="row-checkbox" data-id="${opt.local_id}" ${isChecked ? 'checked' : ''}>
                        <button class="btn-edit" data-id="${opt.local_id}" title="Редагувати">✎</button>
                    </div>
                    <div class="pseudo-table-cell cell-id" data-tooltip="${opt.local_id}">${opt.local_id}</div>

                    <div class="pseudo-table-cell cell-linked-cats" data-tooltip="${opt.parentCharacteristicCategoryNames}">${opt.parentCharacteristicCategoryNames || '—'}</div>
                    <div class="pseudo-table-cell" data-tooltip="${opt.parentCharacteristicName}">${opt.parentCharacteristicName}</div>

                    <div class="pseudo-table-cell" data-tooltip="${opt.name_uk}">${opt.name_uk || '—'}</div>                    
                    <div class="pseudo-table-cell" data-tooltip="${opt.etalon_name}">${opt.etalon_name || '—'}</div>
                    <div class="pseudo-table-cell" data-tooltip="${opt.rztk_name}">${opt.rztk_name || '—'}</div>

                    
                </div>
            `;
            }).join('');
        }
        
        updateCounters(entityType, pageData.length, filteredData.length);
        updatePaginationUI(entityType, filteredData.length);
        updateSortUI(entityType);

    } catch (error) { 
        console.error(`Помилка рендерингу ${entityType}:`, error);
        tableBody.innerHTML = `<p style="padding: 16px; color: red;">Помилка: ${error.message}</p>`;
    } finally { 
        dispatchRenderComplete(entityType); 
    }
}


// ========================================================================
// === HELPER FUNCTIONS (Допоміжні функції) ===
// ========================================================================

/**
 * (ВИПРАВЛЕНО) Обробляє дані категорій, обчислюючи рівень вкладеності та
 * коректну кількість прив'язаних характеристик.
 */
function processCategoriesData(categoriesData, characteristicsData) {
    const categoryMap = new Map();
    const charCountMap = new Map();

    // Ініціалізуємо лічильники
    categoriesData.forEach(cat => {
        charCountMap.set(cat.local_id, 0);
    });

    // Рахуємо глобальні та специфічні характеристики
    const globalCharCount = characteristicsData.filter(char => char.is_global === 'TRUE').length;
    characteristicsData.forEach(char => {
        if (char.is_global !== 'TRUE' && char.category_local_ids) {
            char.category_local_ids.split(',').forEach(id => {
                const trimmedId = id.trim();
                if (charCountMap.has(trimmedId)) {
                    charCountMap.set(trimmedId, charCountMap.get(trimmedId) + 1);
                }
            });
        }
    });

    // Створюємо фінальну мапу категорій з усіма даними
    categoriesData.forEach(cat => {
        const specificCharCount = charCountMap.get(cat.local_id) || 0;
        categoryMap.set(cat.local_id, {
            ...cat,
            level: 0,
            charCount: specificCharCount + globalCharCount // (ВИПРАВЛЕНО) Коректний підрахунок
        });
    });

    // Розраховуємо рівень вкладеності
    categoryMap.forEach(cat => {
        let current = cat;
        let level = 0;
        const visited = new Set();
        while (current && current.parent_local_id) {
            if (visited.has(current.local_id)) {
                console.warn("Виявлено циклічну залежність для категорії:", cat.local_id);
                level = 99;
                break;
            };
            visited.add(current.local_id);
            current = categoryMap.get(current.parent_local_id);
            level++;
        }
        cat.level = level;
    });

    return Array.from(categoryMap.values());
}
// /scripts/components/tabs.js (оновлений)
import { renderCategoriesTable, renderCharacteristicsTable, renderOptionsTable } from './table.js';

export function initTabs() {
    document.querySelector('.tabs-head').addEventListener('click', handleTabClick);
}

export async function handleTabClick(event) {
    const clickedButton = event.target.closest('.tab-button');
    if (!clickedButton) return;

    document.querySelector('.tabs-head').querySelectorAll('.tab-button').forEach(btn => btn.classList.remove('active'));
    document.querySelectorAll('.tab-content').forEach(content => content.classList.remove('active'));

    clickedButton.classList.add('active');
    const tabToActivate = clickedButton.dataset.tab;
    document.getElementById(tabToActivate)?.classList.add('active');

    // Використовуємо await, щоб дочекатись завантаження даних
    switch (tabToActivate) {
        case 'categories':
            await renderCategoriesTable();
            break;
        case 'characteristics':
            await renderCharacteristicsTable();
            break;
        case 'options':
            await renderOptionsTable();
            break;
    }
}
// scripts/components/toast.js

/**
 * Знаходить або створює контейнер для toast-повідомлень.
 */
function getOrCreateToastContainer() {
    let container = document.getElementById('toast-container');
    if (!container) {
        container = document.createElement('div');
        container.id = 'toast-container';
        document.body.appendChild(container);
    }
    return container;
}

/**
 * Показує спливаюче повідомлення (toast).
 * @param {string} message - Текст повідомлення.
 * @param {string} [type='success'] - Тип повідомлення ('success', 'error', 'info').
 * @param {number} [duration=3000] - Тривалість показу в мілісекундах.
 */
export function showToast(message, type = 'success', duration = 3000) {
    const toastContainer = getOrCreateToastContainer();

    const toast = document.createElement('div');
    toast.className = `toast toast--${type}`;
    toast.textContent = message;

    toastContainer.appendChild(toast);

    // Запускаємо анімацію появи
    setTimeout(() => {
        toast.classList.add('toast--visible');
    }, 10);

    // Зникнення та видалення після завершення тривалості
    setTimeout(() => {
        toast.classList.remove('toast--visible');
        
        // Чекаємо завершення анімації зникнення перед видаленням з DOM
        toast.addEventListener('transitionend', () => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        });
    }, duration);
}
// scripts/features/deleteConfirmationModal.js

let resolveCallback;

async function showModal(analysisData) {
    const response = await fetch('modals/delete-confirmation-modal.html');
    const html = await response.text();
    document.getElementById('modal-placeholder').innerHTML = html;

    populateModal(analysisData);
    attachEventListeners();
}

function populateModal(data) {
    const summaryEl = document.getElementById('delete-summary-text');
    const detailsEl = document.getElementById('delete-details-container');
    const btnSafe = document.getElementById('btn-delete-safe');
    const btnCascade = document.getElementById('btn-delete-cascade');

    const totalSelected = data.safeToDelete.length + data.parentsInSelection.length;
    summaryEl.textContent = `Вибрано ${totalSelected} елементів. Серед них ${data.parentsInSelection.length} мають залежності.`;

    let detailsHtml = '';
    if (data.parentsInSelection.length > 0) {
        // Визначаємо, про які залежності йдеться
        const parent = data.parentsInSelection[0];
        let dependencyText = 'дочірніх елементів';
        if (parent.entityType === 'options') dependencyText = 'прив\'язаних опцій';
        if (parent.entityType === 'characteristics') dependencyText = 'залежних характеристик';

        detailsHtml += `<p><strong>Елементи, що мають залежності:</strong></p>`;
        detailsHtml += '<ul class="deletion-details-list">';
        data.parentsInSelection.forEach(p => {
            detailsHtml += `<li><strong>${p.name_uk}</strong> (має ${p.linkedEntities.length} ${dependencyText})</li>`;
        });
        detailsHtml += '</ul>';
    }
    detailsEl.innerHTML = detailsHtml;

    // Підрахунок загальної кількості елементів для каскадного видалення
    let cascadeCount = 0;
    if (data.cascadeDeleteList) {
        cascadeCount = Object.values(data.cascadeDeleteList).reduce((sum, arr) => sum + arr.length, 0);
    }

    if (data.safeToDelete.length > 0) {
        btnSafe.style.display = 'block';
        btnSafe.querySelector('.label').textContent = `Видалити безпечні (${data.safeToDelete.length})`;
    } else {
        btnSafe.style.display = 'none';
    }

    if (data.parentsInSelection.length > 0 && cascadeCount > 0) {
        btnCascade.style.display = 'block';
        btnCascade.querySelector('.label').textContent = `Видалити все (${cascadeCount})`;
    } else {
        btnCascade.style.display = 'none';
    }
}


function attachEventListeners() {
    const modal = document.querySelector('#modal-placeholder .modal-overlay');
    modal.querySelector('.modal-close-btn').addEventListener('click', () => resolveAndClose('cancel'));
    modal.querySelector('#btn-cancel-delete').addEventListener('click', () => resolveAndClose('cancel'));
    modal.querySelector('#btn-delete-safe').addEventListener('click', () => resolveAndClose('safe'));
    modal.querySelector('#btn-delete-cascade').addEventListener('click', () => resolveAndClose('cascade'));
}

function resolveAndClose(choice) {
    if (resolveCallback) {
        resolveCallback(choice);
    }
    document.getElementById('modal-placeholder').innerHTML = '';
}

export function showDeleteConfirmationModal(analysisData) {
    showModal(analysisData);
    return new Promise(resolve => {
        resolveCallback = resolve;
    });
}
// scripts/features/pagination.js (ПОВНА ОНОВЛЕНА ВЕРСІЯ)

import { updatePaginationState, renderActiveTable, getPaginationState } from '../components/table.js';

const footer = document.querySelector('.footer');
const navContainer = document.getElementById('pagination-nav-container');
const pageSizeSelector = document.getElementById('page-size-selector');
const pageSizeLabel = document.getElementById('page-size-label');

export function initPagination() {
    if (!footer) return;
    
    // Делегований слухач для кнопок навігації та опцій розміру
    footer.addEventListener('click', handlePaginationClick);

    // Слухач для відкриття/закриття меню розміру сторінки
    pageSizeSelector.addEventListener('click', (e) => {
        if (e.target.closest('.page-size-trigger')) {
            pageSizeSelector.classList.toggle('is-open');
        }
    });

    // Закриття меню при кліку поза ним
    document.addEventListener('click', (e) => {
        if (!pageSizeSelector.contains(e.target)) {
            pageSizeSelector.classList.remove('is-open');
        }
    });
}

export function updatePaginationUI(entityType, totalFilteredItems) {
    const state = getPaginationState(entityType);
    if (!state) return;

    const { currentPage, pageSize } = state;
    const totalPages = Math.ceil(totalFilteredItems / pageSize);

    // Оновлюємо текст на головній кнопці селектора
    pageSizeLabel.textContent = pageSize > 1000 ? 'Всі' : pageSize;

    // Генеруємо та рендеримо кнопки навігації
    renderPageNumbers(currentPage, totalPages);
}

function handlePaginationClick(event) {
    const button = event.target.closest('.page-btn, .page-size-option');
    if (!button) return;

    const action = button.dataset.action;
    const page = button.dataset.page;
    const newPageSize = button.dataset.pageSize;
    
    const activeTab = document.querySelector('.tab-content.active');
    if (!activeTab) return;
    
    const entityType = activeTab.id;
    const state = getPaginationState(entityType);
    if (!state) return;

    let { currentPage, pageSize, filteredData } = state;
    const totalPages = Math.ceil(filteredData.length / pageSize);
    let needsRender = false;

    if (newPageSize) { // Зміна розміру сторінки
        pageSizeSelector.classList.remove('is-open');
        if (parseInt(newPageSize) !== pageSize) {
            updatePaginationState(entityType, { pageSize: parseInt(newPageSize), currentPage: 1 });
            needsRender = true;
        }
    } else if (page) { // Клік на конкретну сторінку
        const newPageNum = parseInt(page);
        if (newPageNum !== currentPage) {
            updatePaginationState(entityType, { currentPage: newPageNum });
            needsRender = true;
        }
    } else if (action) { // Клік на стрілки
        let newPage = currentPage;
        if (action === 'prev') newPage = Math.max(1, currentPage - 1);
        if (action === 'next') newPage = Math.min(totalPages, currentPage + 1);
        if (newPage !== currentPage) {
            updatePaginationState(entityType, { currentPage: newPage });
            needsRender = true;
        }
    }

    if (needsRender) {
        renderActiveTable();
    }
}

/**
 * Генерує HTML для кнопок навігації по сторінках.
 */
function renderPageNumbers(currentPage, totalPages) {
    navContainer.innerHTML = ''; // Очищуємо контейнер

    // Кнопка "Назад"
    const prevBtn = createPageButton({ icon: '<', action: 'prev', disabled: currentPage === 1 });
    navContainer.appendChild(prevBtn);

    const pageNumbers = getPageNumbers(totalPages, currentPage);
    
    pageNumbers.forEach(pageNum => {
        if (typeof pageNum === 'string') {
            const ellipsis = document.createElement('span');
            ellipsis.className = 'page-ellipsis';
            ellipsis.textContent = '...';
            navContainer.appendChild(ellipsis);
        } else {
            const pageBtn = createPageButton({
                text: pageNum,
                page: pageNum,
                active: pageNum === currentPage
            });
            navContainer.appendChild(pageBtn);
        }
    });

    // Кнопка "Вперед"
    const nextBtn = createPageButton({ icon: '>', action: 'next', disabled: currentPage >= totalPages });
    navContainer.appendChild(nextBtn);
}

/**
 * Створює елемент кнопки пагінації.
 */
function createPageButton({ text, icon, page, action, active = false, disabled = false }) {
    const btn = document.createElement('button');
    btn.className = 'page-btn';
    if (active) btn.classList.add('active');
    if (page) btn.dataset.page = page;
    if (action) btn.dataset.action = action;
    btn.disabled = disabled;
    btn.innerHTML = text || icon;
    return btn;
}

/**
 * Алгоритм для генерації масиву номерів сторінок з "трикрапкою".
 */
function getPageNumbers(totalPages, currentPage, maxVisible = 7) {
    if (totalPages <= maxVisible) {
        return Array.from({ length: totalPages }, (_, i) => i + 1);
    }

    const sideWidth = Math.floor((maxVisible - 3) / 2);
    const leftWidth = currentPage - 1;
    const rightWidth = totalPages - currentPage;

    if (leftWidth < sideWidth + 1) {
        return [
            ...Array.from({ length: maxVisible - 2 }, (_, i) => i + 1),
            '...',
            totalPages
        ];
    }
    
    if (rightWidth < sideWidth + 1) {
        return [
            1,
            '...',
            ...Array.from({ length: maxVisible - 2 }, (_, i) => totalPages - (maxVisible - 3) + i)
        ];
    }

    return [
        1,
        '...',
        ...Array.from({ length: maxVisible - 4 }, (_, i) => currentPage - sideWidth + 2 + i),
        '...',
        totalPages
    ];
}
// scripts/features/search.js

import { getPaginationState, setFilteredData, renderActiveTable } from '../components/table.js';

export function initSearch() {
    const searchInput = document.getElementById('searchInput');
    if (!searchInput) return;

    const handleInput = () => applyFilter(searchInput);
    searchInput.addEventListener('input', handleInput);
    searchInput.addEventListener('search', handleInput);
}

function applyFilter(searchInput) {
    const query = searchInput.value.toLowerCase().trim();
    const activeTab = document.querySelector('.tab-content.active');
    if (!activeTab) return;

    const entityType = activeTab.id;
    const state = getPaginationState(entityType);
    if (!state) return;

    const { sourceData } = state;

    // Фільтруємо вихідний масив даних
    const filteredData = sourceData.filter(row => {
        if (query === '') return true;
        // Перебираємо значення об'єкта в пошуках збігу
        return Object.values(row).some(value => 
            String(value).toLowerCase().includes(query)
        );
    });

    // Оновлюємо відфільтровані дані в state
    setFilteredData(entityType, filteredData);
    // Запускаємо повний пере-рендерінг таблиці (який врахує і пагінацію)
    renderActiveTable();
}
// scripts/features/sorting.js (ПОВНА ВИПРАВЛЕНА ВЕРСІЯ)

import { getPaginationState, updatePaginationState, renderActiveTable } from '../components/table.js';

export function initSorting() {
    document.body.addEventListener('click', handleSortClick);
}

async function handleSortClick(event) {
    const headerCell = event.target.closest('.sortable-header');
    if (!headerCell) return;

    const modalContext = headerCell.closest('.modal-overlay');
    const tabContext = headerCell.closest('.tab-content');
    if (!tabContext && !modalContext) return;

    const entityType = tabContext ? tabContext.id : 'categories'; 
    const sortKey = headerCell.dataset.sortKey;

    const state = getPaginationState(entityType);
    if (!state) return;
    
    let newSortOrder;

    if (state.sortKey === sortKey) {
        newSortOrder = state.sortOrder === 'asc' ? 'desc' : 'asc';
    } else {
        newSortOrder = 'asc';
    }

    updatePaginationState(entityType, { sortKey: sortKey, sortOrder: newSortOrder });

    if (modalContext) {
        // У модалці відправляємо легку подію для сортування на місці, не зачіпаючи вікно
        document.dispatchEvent(new CustomEvent('sidePanelSortChanged', {
            detail: { entityType }
        }));
    } else {
        // На основній сторінці просто перерендеримо активну таблицю
        renderActiveTable();
    }
}

export function updateSortUI(entityType) {
    const state = getPaginationState(entityType);
    if (!state) return;
    
    const containers = document.querySelectorAll(`#${entityType}, #children-panel, #characteristics-panel`);

    containers.forEach(container => {
        if (!container) return;

        container.querySelectorAll('.sort-indicator').forEach(indicator => {
            indicator.className = 'sort-indicator';
        });

        if (state.sortKey) {
            const activeHeader = container.querySelector(`[data-sort-key="${state.sortKey}"]`);
            if (activeHeader) {
                const indicator = activeHeader.querySelector('.sort-indicator');
                if (indicator) {
                    indicator.classList.add(state.sortOrder === 'asc' ? 'sort-asc' : 'sort-desc');
                }
            }
        }
    });
}
// scripts/components/toast.js

/**
 * Знаходить або створює контейнер для toast-повідомлень.
 */
function getOrCreateToastContainer() {
    let container = document.getElementById('toast-container');
    if (!container) {
        container = document.createElement('div');
        container.id = 'toast-container';
        document.body.appendChild(container);
    }
    return container;
}

/**
 * Показує спливаюче повідомлення (toast).
 * @param {string} message - Текст повідомлення.
 * @param {string} [type='success'] - Тип повідомлення ('success', 'error', 'info').
 * @param {number} [duration=3000] - Тривалість показу в мілісекундах.
 */
export function showToast(message, type = 'success', duration = 3000) {
    const toastContainer = getOrCreateToastContainer();

    const toast = document.createElement('div');
    toast.className = `toast toast--${type}`;
    toast.textContent = message;

    toastContainer.appendChild(toast);

    // Запускаємо анімацію появи
    setTimeout(() => {
        toast.classList.add('toast--visible');
    }, 10);

    // Зникнення та видалення після завершення тривалості
    setTimeout(() => {
        toast.classList.remove('toast--visible');
        
        // Чекаємо завершення анімації зникнення перед видаленням з DOM
        toast.addEventListener('transitionend', () => {
            if (toast.parentNode) {
                toast.parentNode.removeChild(toast);
            }
        });
    }, duration);
}
// scripts/features/tooltip.js (ОНОВЛЕНА ВЕРСІЯ)

let tooltipElement;

/**
 * Ініціалізує систему кастомних спливаючих підказок.
 */
export function initTooltips() {
    document.body.addEventListener('mouseover', handleMouseOver);
    document.body.addEventListener('mouseout', handleMouseOut);
    document.body.addEventListener('mousemove', handleMouseMove);
}

function handleMouseOver(event) {
    const target = event.target.closest('[data-tooltip]');
    if (!target) return;

    // ===================================================================
    // === НОВА ПЕРЕВІРКА: Показуємо підказку, лише якщо текст не вміщується ===
    // ===================================================================
    // scrollWidth - це повна ширина вмісту, clientWidth - видима ширина.
    // Якщо повна ширина більша за видиму, значить текст обрізано.
    if (target.scrollWidth <= target.clientWidth) {
        return; // Виходимо, якщо весь текст вже видно
    }
    // ===================================================================

    const tooltipText = target.getAttribute('data-tooltip');
    if (!tooltipText) return;

    // Створюємо елемент підказки
    tooltipElement = document.createElement('div');
    tooltipElement.className = 'custom-tooltip';
    tooltipElement.textContent = tooltipText;
    document.body.appendChild(tooltipElement);

    // Позиціонуємо його і робимо видимим
    positionTooltip(event);
    requestAnimationFrame(() => {
        if (tooltipElement) {
            tooltipElement.classList.add('visible');
        }
    });
}

function handleMouseOut(event) {
    if (tooltipElement) {
        tooltipElement.remove();
        tooltipElement = null;
    }
}

function handleMouseMove(event) {
    if (tooltipElement) {
        positionTooltip(event);
    }
}

function positionTooltip(event) {
    const offsetX = 15;
    const offsetY = 15;
    
    let x = event.clientX + offsetX;
    let y = event.clientY + offsetY;

    // Використовуємо requestAnimationFrame для плавного оновлення позиції
    // та для того, щоб отримати розміри елемента після його рендерингу.
    requestAnimationFrame(() => {
        if (!tooltipElement) return;

        const tooltipRect = tooltipElement.getBoundingClientRect();
        
        // Перевірка, щоб підказка не виходила за межі екрану
        if (x + tooltipRect.width > window.innerWidth) {
            x = event.clientX - tooltipRect.width - offsetX;
        }
        if (y + tooltipRect.height > window.innerHeight) {
            y = event.clientY - tooltipRect.height - offsetY;
        }

        tooltipElement.style.left = `${x}px`;
        tooltipElement.style.top = `${y}px`;
    });
}
/* styles/main.css */
/* Імпортуємо root.css */
@import url('root.css');

/* Імпортуємо компоненти */
@import url('components/_layout.css');
@import url('components/_tabs.css');
@import url('components/_table.css');
@import url('components/_buttons.css');
@import url('components/_forms.css');
@import url('components/_modal.css');
@import url('components/_toast.css');
@import url('components/_lines.css');
@import url('components/_select.css');
@import url('components/_pagination.css');
@import url('components/_tooltip.css');
@import url('components/_progress-bar.css');

* {
  box-sizing: border-box;
  margin: 0;
  padding: 0;
}

body {
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
  /* Використовуємо нові системні токени напряму */
  background-color: var(--color-surface);
  color: var(--color-on-surface);
  height: 100vh;
  display: flex;
  padding: var(--space-m);
}

/*ДОПОМІЖНІ СТИЛІ*/
::placeholder {
  /* Використовуємо On Surface Variant з меншою прозорістю */
  color: var(--color-on-surface-v);
  opacity: 0.6;
}

::-webkit-scrollbar {
  background-color: transparent;
  width: 10px;
  height: 10px;
}

::-webkit-scrollbar-thumb {
  background-color: var(--color-outline);
  border-radius: var(--radius-full);
}

::-webkit-scrollbar-thumb:hover {
  background-color: var(--color-on-surface-v);
}

::selection {
  /* Використовуємо Main Container кольори для виділення тексту */
  color: var(--color-on-main);
  background-color: var(--color-main);
}
:root {        
    --color-main: #006a63;
    --color-on-main: #FFFFFF;    --color-main-c: #b0f1eb;
    --color-on-main-c: #00201d;
    --color-secondary: #4c635d;
    --color-on-secondary: #FFFFFF;
    --color-secondary-c: #b7d5cc;
    --color-on-secondary-c: #0a1f1a;
    --color-accent: #b91d21;
    --color-on-accent: #FFFFFF;
    --color-accent-c: #ffdad6;
    --color-on-accent-c: #410003;
    --color-error: #9c4332;
    --color-on-error: #FFFFFF;
    --color-error-c: #ffdbd2;
    --color-on-error-c: #3e0900;
    
    --color-surface: #f8faf9;
    --color-on-surface: #191c1c;
    --color-on-surface-v: #404947;
    --color-surface-c-lowest: #FFFFFF;    
    --color-surface-c-low: #f2f4f3;
    --color-surface-c: #eceeed;           
    --color-surface-c-high: #e7e9e8;
    --color-surface-c-highest: #e1e3e2;   
    
    --color-outline: #707978;    --color-outline-v: #c0c9c7;
    
    --color-scrim: rgba(0, 0, 0, 0.32);    --color-inverse-surface: #2e3130;
    --color-inverse-on-surface: #f2f4f3;

    --radius-xs: 4px;   
    --radius-s: 8px;    
    --radius-m: 12px;   
    --radius-l: 16px;   
    --radius-xl: 28px;  
    --radius-full: 9999px; 
    --shadow-1: 0px 1px 3px 1px rgba(0, 0, 0, 0.15), 0px 1px 2px 0px rgba(0, 0, 0, 0.30);
    --shadow-2: 0px 2px 6px 2px rgba(0, 0, 0, 0.15), 0px 1px 2px 0px rgba(0, 0, 0, 0.30);
    --shadow-3: 0px 4px 8px 3px rgba(0, 0, 0, 0.15), 0px 1px 3px 0px rgba(0, 0, 0, 0.30);
    --space-xxs: 4px;
    --space-xs: 8px;
    --space-s: 12px;
    --space-m: 16px;
    --space-l: 24px;
        
    --border-radius-s: var(--radius-xs);
    --border-radius-m: var(--radius-m);
    --shadow-s: var(--shadow-1);
    --shadow-m: var(--shadow-2);
    --shadow-l: var(--shadow-3);
    --app-bg: var(--color-surface);
    --content-bg: var(--color-surface-c-lowest);
    --header-bg: var(--color-surface);
    --footer-bg: var(--color-surface-c);
    --hover-bg: rgba(0,0,0,0.05); 
    --text-primary: var(--color-on-surface);
    --text-secondary: var(--color-on-surface-v);
    --text-light: var(--color-on-main);
    --border-color: var(--color-outline);
    --border-color-light: var(--color-outline-v);
    --input-border-color: var(--color-outline);
    --interactive-color: var(--color-main);
    --status-success-bg: var(--color-main);
    --status-error-bg: var(--color-error);
    --status-info-bg: var(--color-secondary);
    --modal-overlay-bg: var(--color-scrim);
    --white: #FFFFFF;
}





@media (prefers-color-scheme: dark) {
    :root {
        
        --color-main: #68d8ce;
        --color-on-main: #003733;
        --color-main-c: #00504b;
        --color-on-main-c: #b0f1eb;

        
        --color-secondary: #b1cbc4;
        --color-on-secondary: #1f3530;
        --color-secondary-c: #354b46;
        --color-on-secondary-c: #cde8e0;

        
        --color-accent: #ffb3ac;
        --color-on-accent: #680008;
        --color-accent-c: #930010;
        --color-on-accent-c: #ffdad6;

        
        --color-error: #ffb5a4;
        --color-on-error: #5f1506;
        --color-error-c: #7e2a1b;
        --color-on-error-c: #ffdbd2;

        
        --color-surface: #121514;
        --color-on-surface: #e1e3e2;
        --color-on-surface-v: #c0c9c7;

        
        --color-surface-c-lowest: #0d100f;
        --color-surface-c-low: #191c1c;
        --color-surface-c: #1d201f;
        --color-surface-c-high: #272b2a;
        --color-surface-c-highest: #323534;

        
        --color-outline: #8a9391;
        --color-outline-v: #404947;

        
        --color-inverse-surface: #e1e3e2;
        --color-inverse-on-surface: #2e3130;

        
        --hover-bg: rgba(255,255,255,0.08); 
    }
}
/* styles/components/_buttons.css */
@import url('buttons/_btn-secondary.css');
@import url('buttons/_connected-button.css');
@import url('buttons/_btn-edit.css');
@import url('buttons/_toolbar.css');

/* Базові стилі кнопок */
button {
    background-color: transparent;
    border: none;
    margin: 0;
    padding: 0;
    transition: background-color 0.2s, border-color 0.2s, opacity 0.2s, box-shadow 0.2s;
    background: transparent;
    cursor: pointer;
    font: inherit;
}

button:disabled {
    /* M3 стандартна прозорість для неактивних елементів */
    opacity: 0.38;
    cursor: not-allowed;
    box-shadow: none !important;
}

/* --- Варіанти кнопок --- */

/* .btn-save (Основна кнопка - M3 Filled Button) */
.btn-save {
    display: inline-flex;
    align-items: center;
    justify-content: center;
    height: 40px; /* Стандартна висота M3 */
    padding: 0 var(--space-l); /* 24px padding */
    border-radius: var(--radius-full);

    /* Typography: Label Large */
    font-size: 14px;
    font-weight: 500;

    background-color: var(--color-main);
    color: var(--color-on-main);
    border: none;

    position: relative;
    overflow: hidden; /* Для State Layer */
}

/* M3 State Layer Implementation (::before) */
.btn-save::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    /* Колір шару такий самий як колір тексту (On Main) */
    background-color: var(--color-on-main);
    opacity: 0;
    transition: opacity 0.2s ease;
}

/* Переконуємось, що контент над шаром */
.btn-save span {
    position: relative;
    z-index: 1;
}

/* Стан наведення (Hover): 8% overlay + Elevation 1 */
.btn-save:hover {
    box-shadow: var(--shadow-1);
}
.btn-save:hover::before {
    opacity: 0.08;
}

/* Стан фокусу (Focus): 12% overlay */
.btn-save:focus-visible {
    outline: none;
}
.btn-save:focus-visible::before {
    opacity: 0.12;
}

/* Стан натискання (Active/Pressed): 12% overlay */
.btn-save:active {
    box-shadow: none;
}
.btn-save:active::before {
    opacity: 0.12;
}

/* Стандартний розмір цілі для іконок M3 (40x40px) */
.modal-close-btn {
    max-width: 32px!important;
}

.footer .segment.active {
    background-color: var(--color-main);
    color: var(--color-on-main);
}

/* --- Загальні елементи форм --- */

.form-fieldset {
    border: 1px solid var(--color-outline-v);
    border-radius: var(--radius-m);
    padding: var(--space-m);
    margin-bottom: var(--space-m);
}

.form-fieldset legend {
    padding: 0 8px;
    font-weight: 500;
    font-size: 16px;
    color: var(--color-on-surface);
}

.form-fieldset {
    min-width: 0;
    box-sizing: border-box;
    max-width: 100%;
}

.form-fieldset input[type="text"],
.form-fieldset input[type="number"],
.form-fieldset select {
    width: 100%;
    box-sizing: border-box;
    min-width: 0;
}

.form-group {
    display: flex;
    flex-direction: column;
    margin-bottom: 8px;
}

label {
    margin-bottom: 4px;
    font-size: 12px;
    color: var(--color-on-surface-v);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
}

/* M3: Outlined Text Fields & Selects (Compact Height) */
input[type="text"],
select {
    padding: 8px 16px;
    /* M3: Колір рамки за замовчуванням (Outline) */
    border: 1px solid var(--color-outline);
    /* M3: Радіус за замовчуванням для текстових полів (4px) */
    border-radius: var(--radius-xs);
    font-size: 16px;
    transition: border-color 0.2s, border-width 0.2s, padding 0.2s;
    height: 40px;
    background-color: transparent; /* Outlined поля прозорі */
    color: var(--color-on-surface);
}

/* M3: Стан наведення */
input[type="text"]:hover,
select:hover {
    border-color: var(--color-on-surface);
}

/* M3: Стан фокусу */
input[type="text"]:focus,
select:focus {
    /* M3: Основний колір та товща рамка при фокусі */
    border-color: var(--color-main);
    border-width: 2px;
    outline: none;
    /* Коригування відступів для компенсації товщини рамки (8px 16px -> 7px 15px) */
    padding: 7px 15px;
}

/* --- СТИЛІ МАКЕТУ ФОРМИ (CSS Grid) --- */

.form-grid, .form-grid-2, .form-grid-3, .form-grid-4, .form-grid-5, .form-grid-6 {
    display: grid;
    gap: var(--space-m);
    align-items: start;
}

.form-grid-triple {
    display: grid;
    grid-template-columns: repeat(3, 1fr);
    gap: var(--space-m);
}

.form-grid-2 { grid-template-columns: repeat(2, 1fr); }
.form-grid-3 { grid-template-columns: repeat(3, 1fr); }
.form-grid-4 { grid-template-columns: repeat(4, 1fr); }
.form-grid-5 { grid-template-columns: repeat(5, 1fr); }
.form-grid-6, .form-grid { grid-template-columns: repeat(6, 1fr); } /* 6 колонок за замовчуванням */

/* (НОВЕ) Класи для об'єднання колонок */
.span-1 { grid-column: span 1; }
.span-2 { grid-column: span 2; }
.span-3 { grid-column: span 3; }
.span-4 { grid-column: span 4; }
.span-5 { grid-column: span 5; }
.span-6 { grid-column: span 6; }

/* (НОВЕ) Адаптивний блок для Назв/Приміток */
.form-responsive-pair {
    display: grid;
    grid-template-columns: repeat(2, 1fr);
    gap: var(--space-m);
    align-items: start;
}

.form-input-group {
    display: flex;
    flex-direction: column;
    gap: var(--space-xs); /* Відстань між інпутами в групі */
}

/* Коли відкрита бічна панель, цей блок переходить в 1 колонку */
.side-panel-visible .form-responsive-pair {
    grid-template-columns: 1fr;
}

.input-with-chip {
    position: relative;
    display: flex;
    align-items: center;
}
.input-with-chip input {
    padding-right: 50px !important; 
}
.input-language-chip {
    position: absolute;
    right: 8px;
    background-color: var(--color-surface-c-high);
    color: var(--color-on-surface-v);
    font-size: 12px;
    font-weight: 500;
    padding: 2px 6px;
    border-radius: var(--radius-full);
    pointer-events: none;
}

.marketplace-grid {
    display: grid;
    grid-template-columns: 1fr 2fr 7fr;
    gap: var(--space-m);
    align-items: center;
}

.marketplace-header {
    font-weight: 500;
    font-size: 14px;
    color: var(--color-on-surface-v);
    padding-bottom: 8px;
}

.marketplace-name {
    font-weight: 400;
    font-size: 16px;
    color: var(--color-on-surface);
    margin-bottom: 0;
}

.toggle-switch-segmented {
    position: relative;
    display: inline-block;
    height: 40px;
    flex-shrink: 0;
}

.toggle-switch-segmented input {
    opacity: 0;
    width: 0;
    height: 0;
}

.toggle-switch-segmented .slider {
    position: absolute;
    cursor: pointer;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    /* M3: Рамка контейнера - Outline */
    border: 1px solid var(--color-outline);
    transition: .3s;
    /* ВИПРАВЛЕННЯ: M3 вимагає повного заокруглення для цього компоненту */
    border-radius: var(--radius-full);
    overflow: hidden;
}

/* "Повзунок" (Активний стан) - використовуємо ::before */
.toggle-switch-segmented .slider:before {
    position: absolute;
    content: "";
    height: 100%;
    width: 50%;
    left: 0;
    top: 0;
    /* M3: Фон активного сегмента - Secondary Container */
    background-color: var(--color-secondary);
    transition: transform .3s ease;
    z-index: 1;
    /* Додаємо тонкий розділювач між активним і неактивним сегментом */
    box-shadow: 1px 0 0 var(--color-outline);
}

/* Стилі тексту всередині перемикача */
.toggle-switch-segmented .text-on,
.toggle-switch-segmented .text-off {
    position: absolute;
    width: 50%;
    height: 100%;
    display: flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    font-weight: 500;
    /* M3: Колір неактивного тексту - On Surface */
    color: var(--color-on-surface);
    transition: color 0.3s;
    user-select: none;
    z-index: 2; /* Текст над повзунком */
}

.toggle-switch-segmented .text-on {
    right: 0;
}

.toggle-switch-segmented .text-off {
    left: 0;
}

/* Стан: Увімкнено (Кінцева) - Чекбокс checked */
input:checked + .slider:before {
    transform: translateX(100%);
    /* Змінюємо тінь на ліву сторону для розділення */
    box-shadow: -1px 0 0 var(--color-outline);
}

/* Підсвічуємо активний текст - On Secondary Container */
input:checked + .slider .text-on,
input:not(:checked) + .slider .text-off {
    color: var(--color-on-secondary);
}

.form-grid-complex {
    display: grid;
    grid-template-columns: 1fr 1fr;
    gap: var(--space-m);
}

.form-grid-complex .full-width {
    grid-column: 1 / -1;
}

.custom-select-wrapper.disabled {
    opacity: 0.5;
    pointer-events: none;
    background-color: var(--color-surface-c);
}

/* Універсальне правило для всіх полів вводу та кастомних селектів всередині .form-group */
.form-group input[type="text"],
.form-group input[type="search"],
.form-group textarea,
.form-group .custom-select-wrapper {
    width: 100%;
}

#char-notes {
    padding: 8px 16px;
    border: 1px solid var(--color-outline);
    border-radius: var(--radius-xs);
    font-size: 16px;
    transition: border-color 0.2s, border-width 0.2s, padding 0.2s;
    min-height: 40px;
    height: 40px;
    background-color: transparent;
    color: var(--color-on-surface);
    resize: none;
}

/* Додайте ці класи в кінець файлу styles/components/_forms.css */

.marketplace-section {
    padding-bottom: 16px;
    margin-bottom: 16px;
}

.marketplace-section:not(:last-child) {
    border-bottom: 1px solid var(--color-outline-v);
}

.marketplace-heading {
    margin-bottom: 12px;
    font-weight: 500;
    color: var(--color-on-surface);
}
/* styles/components/_layout.css (M3 Update) */

.main-content {
  display: flex;
  flex-direction: column;
  width: 100%;
  height: 100%;
  /* M3: Використання Surface Container Lowest (Білий у світлій темі) для фону контенту */
  background-color: var(--color-surface-c-lowest);
  /* M3: Збільшений радіус (16px) для основного контейнера */
  border-radius: var(--radius-l);
  overflow: hidden;
  /* M3: Elevation Level 1 */
  box-shadow: var(--shadow-1);
}

.header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-m) var(--space-l);
  /* M3: Використання Outline Variant для тонкого розділювача */
  border-bottom: 1px solid var(--color-outline-v);
  flex-shrink: 0;
  /* Фон відповідає main-content */
  background-color: var(--color-surface-c-lowest);
}

.tabs-container {
  flex-grow: 1;
  display: flex;
  flex-direction: column;
  overflow: hidden;
  /* Збільшені відступи для кращого вигляду */
  padding: var(--space-l);
  min-height: 0;
}

.footer {
  display: flex;
  justify-content: space-between;
  align-items: center;
  padding: var(--space-s) var(--space-l);
  border-top: 1px solid var(--color-outline-v);
  /* M3: Використання Surface Container для контрасту футера */
  background-color: var(--color-surface-c);
  flex-shrink: 0;
}

.header-controls {
    display: flex;
    align-items: center;
    gap: var(--space-m);
}
/* styles/components/_lines.css */
@import url('lines/_search.css');
@import url('lines/_checkbox.css');
/* styles/components/_modal.css (M3 Update) */

.modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    /* M3: Scrim (затемнення фону) */
    background-color: var(--color-scrim);
    z-index: 1000;
    display: flex;
    justify-content: center;
    align-items: center;
    animation: fadeIn 0.3s ease-out;
}

.modal-content {
    background-color: var(--color-surface-c-high);
    padding: var(--space-l);
    border-radius: var(--radius-xl);
    box-shadow: var(--shadow-3);
    width: 85vw;
    min-width: 85vw;
    height: 85vh;
    animation: scaleIn 0.3s ease-out;
    display: flex;
    flex-direction: column;
    overflow: hidden;
}

.modal-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    border-bottom: none;
    padding-bottom: 0;
    margin-bottom: var(--space-m);
    flex-shrink: 0;
    gap: 24px;
}

.modal-header h2 {
    /* M3: Типографіка - Headline Small (24px) */
    font-size: 1.5rem;
    font-weight: 400;
    line-height: 32px;
    margin: 0;
    color: var(--color-on-surface);
}

.modal-header .header-actions {
    display: flex;
    align-items: center;
    gap: var(--space-xs);
}

.modal-body--split {
    display: flex;
    overflow: hidden;
    flex-grow: 1;
    min-height: 0;
}

.scrollable-panel {
    overflow-y: auto;
    min-height: 0;
}

.form-section {
    width: 100%;
    flex-shrink: 0;
    transition: width 0.4s ease-in-out;
}

.related-section {
    width: 0;
    flex-shrink: 0;
    opacity: 0;
    transition: width 0.4s ease-in-out, opacity 0.4s ease-in-out;
    padding-left: 0;
}

.modal-body--split.side-panel-visible .form-section {
    width: 60%;
    min-width: 0;
}

.modal-body--split .modal-form-container {
    flex: 1 1 auto;
    min-width: 0;
}

.related-section.visible {
    width: 40%;
    opacity: 1;
    display: block;
    padding: 0 var(--space-l);
}

/* Анімації */
@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

@keyframes scaleIn {
    from { transform: scale(0.8); opacity: 0; }
    to { transform: scale(1); opacity: 1; }
}

.panel-table-actions {
    display: flex;
    gap: var(--space-xs);
    padding: 0 0 var(--space-m) 0;
}

.modal-title-container {
    display: flex;
    align-items: center;
    gap: var(--space-m);
}

/* Стилі для модального вікна підтвердження видалення */
.modal-footer {
    padding-top: var(--space-l);
    margin-top: var(--space-l);
    border-top: 1px solid var(--color-outline-v);
    display: flex;
    justify-content: flex-end;
}

.deletion-details-list {
    list-style-type: none;
    padding-left: var(--space-m);
    margin-top: var(--space-m);
    border-left: 2px solid var(--color-outline-v);
}

.deletion-details-list li {
    padding: var(--space-xxs) 0;
}

/* Стиль для "небезпечної" кнопки */
.accent-btn {
    background-color: var(--color-error-c);
    color: var(--color-on-error-c);
}
.accent-btn:hover {
    box-shadow: var(--shadow-1);
}
/* styles/components/_pagination.css */

.pagination-container {
    display: flex;
    justify-content: center;
    align-items: center;
    gap: 16px;
    flex-wrap: wrap;
}

/* 1. Компонент навігації по сторінках */
.pagination-nav {
    display: flex;
    align-items: center;
    background-color: var(--color-surface-c-lowest);
    border-radius: var(--radius-full);
    padding: 4px;
    gap: 4px;
    box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
}

.page-btn,
.page-ellipsis {
    border: none;
    background-color: transparent;
    font-family: inherit;
    font-size: 14px;
    font-weight: 500;
    color: var(--color-on-surface-v);
    cursor: pointer;
    border-radius: var(--radius-full);
    min-width: 32px;
    height: 32px;
    display: inline-flex;
    justify-content: center;
    align-items: center;
    transition: background-color 150ms ease-out, color 150ms ease-out;
}

.page-btn:hover:not(:disabled) {
    background-color: var(--color-secondary);
    color: var(--color-on-secondary);
}

.page-btn:disabled {
    color: var(--color-outline);
    cursor: not-allowed;
}

.page-btn.active {
    background-color: var(--color-secondary);
    color: var(--color-on-secondary);
    font-weight: 600;
    box-shadow: var(--shadow-1);
}

.page-ellipsis {
    cursor: default;
    min-width: 24px;
}

/* 2. Компонент вибору розміру сторінки (FAB-like menu) */
/* Головний контейнер, який позиціонує все меню */
.page-size-selector {
    position: relative;
}

/* Основна кнопка (FAB) */
.page-size-trigger {
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;
    width: 56px;
    height: 56px;
    border-radius: 50%;
    background-color: var(--color-secondary);
    color: var(--color-on-secondary);
    box-shadow: var(--shadow-2);
    cursor: pointer;
    border: none;
    transition: box-shadow 0.2s ease-in-out;
}

.page-size-trigger:hover {
    box-shadow: var(--shadow-3);
}

/* (ЗМІНЕНО) Робимо лейбл видимим і стилізуємо його */
#page-size-label {
    display: block;
    font-size: 16px;
    font-weight: 500;
}

/* (ВИДАЛЕНО) Більше не створюємо іконку "+" через CSS */
/* .page-size-trigger::before, .page-size-trigger::after { ... } */
/* (ВИДАЛЕНО) Анімація "+" в "х" більше не потрібна */
/* .page-size-selector.is-open .page-size-trigger { ... } */


/* Контейнер для опцій, тепер він невидимий */
.page-size-menu {
    position: absolute;
    bottom: 0;
    right: 0;
    width: auto;
    height: auto;
    pointer-events: none;
}

/* Стиль для кожної окремої опції (пігулки) */
.page-size-option {
    position: absolute;
    right: 4px;
    bottom: 0;

    display: flex;
    align-items: center;
    justify-content: flex-end;

    width: auto;
    white-space: nowrap;
    padding: 8px 16px;

    background-color: var(--color-surface-c-high);
    color: var(--color-on-surface);
    border-radius: var(--radius-full);
    box-shadow: var(--shadow-2);

    cursor: pointer;
    border: none;

    opacity: 0;
    transform: translateY(10px);
    pointer-events: none;
    transition: opacity 0.2s ease-out, transform 0.2s ease-out;
}

.page-size-option:hover {
    background-color: var(--color-secondary-c);
}

.page-size-selector.is-open .page-size-option {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
}

/* Позиціонування та затримка анімації для кожної опції */
.page-size-option:nth-child(1) {
    bottom: 68px;
    transition-delay: 0.20s;
}

.page-size-option:nth-child(2) {
    bottom: 116px;
    transition-delay: 0.15s;
}

.page-size-option:nth-child(3) {
    bottom: 164px;
    transition-delay: 0.10s;
}

.page-size-option:nth-child(4) {
    bottom: 212px;
    transition-delay: 0.05s;
}

.page-size-option:nth-child(5) {
    bottom: 260px;
    transition-delay: 0s;
}
/* styles/components/_progress-bar.css */
.progress-bar-container {
    width: 100%;
    height: 12px;
    background-color: var(--color-surface-c-high);
    border-radius: var(--radius-full);
    overflow: hidden;
    position: relative;
}

.progress-bar-fill {
    width: 0%;
    height: 100%;
    background-color: var(--color-main);
    border-radius: var(--radius-full);
    transition: width 0.3s ease-in-out;
    position: relative;
    z-index: 2;
}

.progress-bar-wave {
    position: absolute;
    top: -6px;
    left: 0;
    width: 40px;
    height: 24px;
    background: var(--color-main);
    opacity: 0.8;
    border-radius: 50%;
    animation: wave 2s infinite linear;
    z-index: 1;
    filter: blur(2px);
}

@keyframes wave {
    0% { transform: translateX(-40px) scale(1, 2); }
    100% { transform: translateX(100vw) scale(1, 2); }
}
/* styles/components/_select.css */

.custom-select-wrapper {
    position: relative;
    width: 100%;
    font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
}

.custom-select-trigger {
    display: flex;
    align-items: center;
    justify-content: space-between;
    padding: var(--space-xs) var(--space-m);
    border: 1px solid var(--color-outline);
    border-radius: var(--radius-xs);
    cursor: pointer;
    transition: border-color 150ms ease-in-out, box-shadow 150ms ease-in-out;
    max-height: 40px;
}

.custom-select-wrapper.is-open .custom-select-trigger {
    border-color: var(--color-main);
    box-shadow: 0 0 0 1px var(--color-main);
}

.custom-select-value-container {
    display: flex;
    flex-wrap: wrap;
    gap: var(--space-xxs);
    align-items: center;
    overflow: hidden;
    max-height: 30px; 
}

.custom-select-overflow-chips {
    display: none; /* Ховаємо за замовчуванням */
    flex-wrap: wrap;
    gap: var(--space-xxs);
    padding: var(--space-s);
    border-bottom: 1px solid var(--color-outline-v);
    background-color: var(--color-surface-c-low);
}

.custom-select-chip.is-summary {
    background-color: var(--color-main);
    color: var(--color-on-main);
    font-weight: 500;
    min-width: 24px;
    height: 24px;
    padding: 2px;
    border-radius: 50%;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    font-size: 14px;
    line-height: 1;
}

.custom-select-placeholder {
    color: var(--color-on-surface-v);
    opacity: 0.8;
}

.custom-select-arrow {
    width: 24px;
    height: 24px;
    flex-shrink: 0;
    margin-left: var(--space-xs);
    transition: transform 200ms ease-in-out;
    fill: var(--color-on-surface-v);
}

.custom-select-wrapper.is-open .custom-select-arrow {
    transform: rotate(180deg);
}

.custom-select-panel {
    position: absolute;
    top: calc(100% + var(--space-xxs));
    left: 0;
    right: 0;
    z-index: 100;
    background-color: var(--color-surface-c-high);
    border-radius: var(--radius-m);
    box-shadow: var(--shadow-2);
    opacity: 0;
    transform: translateY(-10px);
    pointer-events: none;
    transition: opacity 150ms ease-in-out, transform 150ms ease-in-out;
    max-height: 250px;
    display: flex;
    flex-direction: column;
}

.custom-select-wrapper.is-open .custom-select-panel {
    opacity: 1;
    transform: translateY(0);
    pointer-events: auto;
}

.custom-select-search-wrapper {
    padding: var(--space-s);
    border-bottom: 1px solid var(--color-outline-v);
}

.custom-select-search {
    width: 100%;
    padding: var(--space-xs);
    border: 1px solid var(--color-outline);
    border-radius: var(--radius-xs);
    background-color: var(--color-surface-c-lowest);
    color: var(--color-on-surface);
}

.custom-select-search:focus {
    outline: none;
    border-color: var(--color-main);
}

.custom-select-options {
    list-style: none;
    padding: var(--space-xs) 0;
    margin: 0;
    overflow-y: auto;
}

.custom-select-option {
    padding: var(--space-s) var(--space-m);
    cursor: pointer;
    transition: background-color 150ms ease-in-out;
    color: var(--color-on-surface);
    display: flex;
    align-items: center;
    gap: var(--space-s);
}

.custom-select-option:hover {
    background-color: var(--hover-bg);
}

.custom-select-option.is-selected {
    background-color: var(--color-main-c);
    color: var(--color-main);
    font-weight: 700;
}

.custom-select-option.is-hidden {
    display: none;
}

/* Стилі для мультиселекта (чіпси) */
.custom-select-chip {
    display: inline-flex;
    align-items: center;
    padding: 2px var(--space-xs);
    background-color: var(--color-secondary-c);
    color: var(--color-on-secondary-c);
    border-radius: var(--radius-full);
    font-size: 14px;
    line-height: 20px;
}

.custom-select-chip__remove {
    margin-left: var(--space-xxs);
    min-width: 24px;
    height: 24px;
    border: none;
    background: none;
    cursor: pointer;
    display: flex;
    align-items: center;
    justify-content: center;
    color: var(--color-on-secondary-c);
    opacity: 0.7;
    padding: 0;
    border-radius: 50%;
}

.custom-select-chip__remove:hover {
    opacity: 1;
    background-color: rgba(0, 0, 0, 0.1);
}

.custom-select-wrapper.disabled {
    opacity: 0.5;
    pointer-events: none;
    background-color: var(--color-surface-c);
}
/* styles/components/_table.css (M3 Update) */

.pseudo-table-container {
  flex-grow: 1;
  overflow-y: auto;
  /* M3: Тонка рамка контейнера (Outline Variant) */
  border: 1px solid var(--color-outline-v);
  /* M3: Радіус картки (12px) */
  border-radius: var(--radius-m);
  min-height: 0;
  scrollbar-gutter: stable;
  background-color: var(--color-surface-c-lowest);
}

.pseudo-table-header,
.pseudo-table-row {
  display: grid;
  grid-template-columns: 100px 160px 70px 1fr 1fr 1fr 1fr 1fr 1fr 1fr 70px;
  /* M3: Тільки горизонтальні роздільники */
  border-bottom: 1px solid var(--color-outline-v);
  align-items: center;
}

/* Стилі для таблиці характеристик */
#characteristics .pseudo-table-header,
#characteristics .pseudo-table-row {
    grid-template-columns: 100px 170px 100px 1fr 1fr 1fr 70px 70px;
}

/* І замініть його на це (додано 2 колонки) */
#options .pseudo-table-header,
#options .pseudo-table-row {
    grid-template-columns: 100px 160px 160px 160px 1fr 1fr 1fr;
}

.pseudo-table-row-inner {
  display: grid;
  grid-template-columns: 100px 1fr;
  border-bottom: 1px solid var(--color-outline-v);
  align-items: center;
}

.pseudo-table-header {
  position: sticky;
  top: 0;
  /* M3: Фон шапки відповідає контейнеру */
  background-color: var(--color-surface-c-lowest);
  font-weight: 500;
  font-size: 14px;
  z-index: 10;
  color: var(--color-on-surface);
}

/* M3: Стан наведення рядка (State Layer - 8% On Surface) */
.pseudo-table-row:hover {
  /* Використовуємо color-mix для створення 8% шару кольору On Surface.
     Це автоматично адаптується до світлої/темної теми. */
  background-color: color-mix(in srgb, transparent, var(--color-on-surface) 8%);
}

.pseudo-table-cell {
  padding: 14px 16px;
  border-right: none;
  box-sizing: border-box;
  white-space: nowrap;
  overflow: hidden;
  text-overflow: ellipsis;
  font-size: 14px;
  color: var(--color-on-surface-v);
}

.pseudo-table-header .pseudo-table-cell {
    padding: 14px 16px;
    color: var(--color-on-surface);
}

.pseudo-table-cell:last-child {
  border-right: none;
}

.cell-actions {
  display: flex;
  gap: var(--space-xs);
}

/* Нові стилі для шапки таблиці */
.header-actions-cell {
    display: flex;
    align-items: center;
    gap: 12px;
}
.header-actions-cell span {
    cursor: default;
}
.is-hidden {
    display: none !important;
}

.side-panel-table .pseudo-table-header,
.side-panel-table .pseudo-table-row-inner {
    grid-template-columns: 120px 1fr;
}

.side-panel-table .pseudo-table-header {
    background-color: var(--color-surface-c-high);
}

.panel-header {
    display: flex;
    flex-wrap: wrap; /* Дозволяє переноситись на новий рядок при потребі */
    align-items: center;
    gap: 16px;
    margin-bottom: 12px;
}

.panel-title {
    margin: 0;
    font-size: 1.2em;
    font-weight: 500;
    margin-right: 16px; 
}

/* Контейнер для пошуку та кнопок */
.panel-controls {
    display: flex;
    align-items: center;
    gap: 16px;
    flex-grow: 1; 
    /* Ключове правило, що притискає контроли вправо */
    margin-left: auto; 
    justify-content: space-between; 
}

.panel-search {
    min-width: 150px;
    max-width: 250px;
    flex-shrink: 1;
}

.side-panel-search {
    width: 100%;
    padding: 6px 10px;
    border: 1px solid var(--color-outline-v);
    border-radius: var(--radius-full);
    background-color: var(--color-surface-c-low);
    color: var(--color-on-surface);
    font-size: 14px;
}

.side-panel-search:focus {
    outline: none;
    border-color: var(--color-main);
}

.panel-actions {
    flex-shrink: 0; 
}

/* Стилі для сортованих колонок */
.sortable-header {
    cursor: pointer;
    user-select: none;
    display: flex;
    justify-content: space-between; /* Розміщує текст і стрілку по краях */
    align-items: center;
}

.sortable-header:hover {
    background-color: var(--hover-bg);
    border-radius: var(--radius-m);
}

/* Індикатор сортування (стрілочка) */
.sort-indicator {
    display: inline-block;
    width: 0;
    height: 0;
    border-left: 5px solid transparent;
    border-right: 5px solid transparent;
    margin-left: 8px;
    opacity: 0.5;
    transition: transform 150ms ease-out, opacity 150ms ease-out;
}

.sortable-header:hover .sort-indicator {
    opacity: 1;
}

/* Стан стрілки "вгору" */
.sort-indicator.sort-asc {
    opacity: 1;
    border-bottom: 5px solid var(--color-on-surface);
}

/* Стан стрілки "вниз" */
.sort-indicator.sort-desc {
    opacity: 1;
    border-top: 5px solid var(--color-on-surface);
}
/* styles/components/_tabs.css (M3 Update) */

/* --- НОВІ СТИЛІ: Навігація вкладок (M3 Primary Tabs) --- */

.tab-nav {
    display: flex;
    flex-direction: row;
    /* M3: Розділювач під всією панеллю вкладок */
    border-bottom: 1px solid var(--color-outline-v);
    /* Відступ перед початком контенту вкладки */
    margin-bottom: var(--space-m);
}

.tab-link {
    padding: 10px 16px;
    cursor: pointer;
    border: none;
    background: transparent;
    position: relative;
    display: flex;
    align-items: center;
    justify-content: center;

    font-size: 14px;
    font-weight: 500;
    line-height: 20px;

    /* Default Color: On Surface Variant */
    color: var(--color-on-surface-v);
    transition: color 0.2s;
}

/* Індикатор активної вкладки */
.tab-link::after {
    content: '';
    position: absolute;
    bottom: 0;
    left: 50%;
    width: 0;
    height: 3px; /* Висота індикатора M3 */
    background-color: var(--color-main);
    /* M3: Індикатор має заокруглені верхні кути */
    border-radius: 3px 3px 0 0;
    transition: width 0.3s cubic-bezier(0.4, 0.0, 0.2, 1), left 0.3s cubic-bezier(0.4, 0.0, 0.2, 1);
}

/* Стан наведення */
.tab-link:hover {
    /* Hover Color: On Surface */
    color: var(--color-on-surface);
}

/* Активний стан */
.tab-link.active {
    /* Active Color: Primary */
    color: var(--color-main);
}

.tab-link.active::after {
    width: 100%;
    left: 0;
}


/* --- Існуючі стилі контенту вкладок --- */

.tab-content {
  display: none;
  flex-grow: 1;
  flex-direction: column;
  min-height: 0;
}

.tab-content.active {
  display: flex;
}

.tab-content-header {
    display: flex;
    justify-content: space-between;
    align-items: center;
    margin-bottom: var(--space-m);
    flex-shrink: 0;
}
/* styles/components/_toast.css (M3 Update) */
#toast-container {
    position: fixed;
    /* M3: Snackbars зазвичай з'являються знизу на десктопі */
    bottom: 20px;
    left: 20px;
    top: auto;
    right: auto;
    z-index: 10000;
    display: flex;
    flex-direction: column-reverse; /* Найновіші зверху */
    gap: 10px;
}

.toast {
    padding: 14px 16px;
    /* M3: Радіус Snackbar (4px) */
    border-radius: 4px;
    /* M3 Elevation Level 3 */
    box-shadow: 0px 8px 12px 6px rgba(0, 0, 0, 0.15), 0px 4px 4px 0px rgba(0, 0, 0, 0.30);

    /* M3: Фон за замовчуванням (Inverse Surface) та текст (Inverse On Surface) */
    background-color: var(--md-sys-color-inverse-surface, #313033);
    color: var(--md-sys-color-inverse-on-surface, #F4EFF4);

    opacity: 0;
    transform: translateY(100%); /* Анімація знизу вгору */
    transition: opacity 0.4s ease, transform 0.4s ease;
    min-width: 288px;
    max-width: 600px;
    /* M3: Типографіка - Body Medium */
    font-size: 14px;
}

.toast--visible {
    opacity: 1;
    transform: translateY(0);
}

/* Варіації статусів */
.toast--success {
    /* Залишаємо стандартний Inverse Surface для успіху */
    background-color: var(--md-sys-color-inverse-surface, #313033);
}

.toast--error {
    /* M3: Використання Error Container для кращої видимості та доступності помилок */
    background-color: var(--md-sys-color-error-container, #F9DEDC);
    color: var(--md-sys-color-on-error-container, #410E0B);
}

.toast--info {
    background-color: var(--md-sys-color-inverse-surface, #313033);
}
/* styles/components/_tooltip.css */

.custom-tooltip {
    position: fixed; /* Позиціонування відносно вікна, щоб уникнути проблем з overflow */
    padding: 6px 12px;
    max-width: 500px;
    font-size: 13px;
    
    /* M3: Використовуємо стилі "Inverse Surface" як у сповіщеннях */
    background-color: var(--color-inverse-surface);
    color: var(--color-inverse-on-surface);

    border-radius: var(--radius-s);
    box-shadow: var(--shadow-2);
    
    z-index: 9999;
    pointer-events: none; /* Підказка не повинна заважати курсору */
    
    /* Анімація появи */
    opacity: 0;
    transform: scale(0.9);
    transition: opacity 150ms ease-out, transform 150ms ease-out;
}

.custom-tooltip.visible {
    opacity: 1;
    transform: scale(1);
}
/* styles/components/buttons/_btn-edit.css (M3 Update - Connected Button Style) */

/* Загальний селектор для всіх варіацій кнопок редагування */
.btn-edit,
[class*="btn-edit-"] {
  /* 1. Скидаємо стандартні стилі */
  appearance: none;
  -webkit-appearance: none;
  -moz-appearance: none;
  padding: 0;
  margin: 0;
  border: none;

  /* 2. Встановлюємо розміри (ідентично до checkbox, 24x24px) */
  width: 24px;
  height: 24px;
  box-sizing: border-box;

  position: relative;
  cursor: pointer;

  /* Налаштування для центрування іконки */
  display: flex;
  justify-content: center;
  align-items: center;

  /* 3. Стандартний стан */
  /* M3: Secondary Container */
  /* Стандартне заокруглення (4px) */
  border-radius: 4px;
  border: 1px solid var(--color-secondary-c);

  /* Анімація морфінгу форми та кольору */
  transition: background-color 0.2s ease, border-radius 0.2s ease;
}

/* Стилі для іконок всередині кнопки (SVG) */
.btn-edit svg,
[class*="btn-edit-"] svg {
    /* Розмір іконки 18px для 24px контейнера для кращого візуального балансу */
    width: 18px;
    height: 18px;
    /* M3: On Secondary Container */
    fill: var(--color-on-secondary-c);
    transition: fill 0.2s ease;
}


/* 4. Активний стан (.active) та стан наведення (Hover) - Морфінг форми */
.btn-edit.active,
.btn-edit:hover,
[class*="btn-edit-"].active,
[class*="btn-edit-"]:hover {
  /* M3: Secondary (Темніший фон) */
  background-color: var(--color-secondary);
  color: var(--color-on-secondary);
  border-radius: 24px;
}

/* Зміна кольору іконки при активації/наведенні */
.btn-edit.active svg,
.btn-edit:hover svg,
[class*="btn-edit-"].active svg,
[class*="btn-edit-"]:hover svg {
    /* M3: On Secondary (Світлий колір) */
    fill: var(--color-on-secondary);
}

/* 5. Стан фокусу (для доступності) */
.btn-edit:focus-visible,
[class*="btn-edit-"]:focus-visible {
    outline: 2px solid var(--color-main);
    outline-offset: 2px;
}
/* styles/components/buttons/_btn-secondary.css (M3 Update - Filled Tonal Button) */

.btn-secondary {
    /* Скидання базових стилів */
    border: none;
    cursor: pointer;
    display: inline-flex;
    align-items: center;
    justify-content: center;
    text-decoration: none;

    /* M3: Стандартна висота 40px */
    height: 40px;
    /* M3: Горизонтальні відступи 24px */
    padding: 0 var(--space-l);
    /* M3: Повне заокруглення (Pill shape) */
    border-radius: var(--radius-full);

    /* M3: Типографіка - Label Large */
    font-size: 14px;
    font-weight: 500;

    /* M3: Фон - Secondary Container */
    background-color: var(--color-secondary-c);
    /* M3: Текст - On Secondary Container */
    color: var(--color-on-secondary-c);

    position: relative;
    overflow: hidden; /* Для State Layer */
    transition: box-shadow 0.2s ease;
}

/* --- M3 State Layers (Використовуємо ::before) --- */
.btn-secondary::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    /* Колір State Layer: такий самий, як колір тексту */
    background-color: var(--color-on-secondary-c);
    opacity: 0;
    transition: opacity 0.2s ease;
}

/* Переконуємось, що контент над State Layer */
.btn-secondary span, .btn-secondary svg {
    position: relative;
    z-index: 1;
}

/* Стан наведення (Hover) - 8% opacity + Elevation 1 */
.btn-secondary:hover {
    box-shadow: var(--shadow-1);
}

.btn-secondary:hover::before {
    opacity: 0.08;
}

/* Стан фокусу (Focus) - 12% opacity */
.btn-secondary:focus-visible {
    outline: none;
}

.btn-secondary:focus-visible::before {
    opacity: 0.12;
}

/* Стан натискання (Pressed) - 12% opacity */
.btn-secondary:active {
    box-shadow: none;
}

.btn-secondary:active::before {
    opacity: 0.12;
}

/* Стан вимкнено (Disabled) */
button.btn-secondary:disabled {
    cursor: not-allowed;
    box-shadow: none;
    /* M3: Неактивний фон (12% On Surface). color-mix адаптується до теми. */
    background-color: color-mix(in srgb, transparent, var(--color-on-surface) 12%);
    /* M3: Неактивний текст (38% On Surface) */
    color: color-mix(in srgb, transparent, var(--color-on-surface) 38%);
    opacity: 1; /* Керуємо кольорами, а не загальною прозорістю */
}
button.btn-secondary:disabled::before {
    opacity: 0; /* Прибираємо State Layer */
}
  /* Основний контейнер */
  .connected-button-group-square,
  .connected-button-group-round
   {
    /* Auto layout */
    display: flex;
    flex-direction: row;
    align-items: center;
    padding: 0px;
    gap: 2px; /* Відстань між сегментами, згідно специфікації */

    position: relative;
    height: 32px; /* Висота визначена висотою сегментів */
  }

  /* Segment (Загальні стилі для всіх кнопок) */
  .segment {
    /* Auto layout */
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;

    /* min-width: 48px; */
    height: 32px;

    /* Inside auto layout */
    flex-grow: 1;
    transition: background-color 0.2s ease, border-radius 0.2s ease;
  }

  /* State-layer (Шар для вирівнювання контенту та відступів) */
  .state-layer {
    /* Auto layout */
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    padding: 6px 12px; /* Забезпечує висоту 32px (20px текст + 6px*2 відступи) */
    gap: 4px;
    isolation: isolate;

    height: 32px;
    align-self: stretch;
  }

  /* Label (Стилі тексту) */
  .label {
    /* M3/label/large */
    font-style: normal;
    font-weight: 500;
    font-size: 14px;
    line-height: 20px;
    letter-spacing: 0.1px;
    white-space: nowrap;
    transition: color 0.2s ease;
  }

  /* --- Стани сегментів та морфінг форми --- */

  /* Стандартний (неактивний) стан */
  .segment {
    /* M3/sys/light/secondary-container */
    background: var(--color-secondary-c);
    /* Стандартне заокруглення для середніх елементів */
    border-radius: 4px;
  }

  .segment .label {
    /* M3/sys/light/on-secondary-container */
    color: var(--color-on-secondary-c);
  }

  /* Спеціальне заокруглення для першого елемента */
  /* Specificity (0, 2, 0) */
.connected-button-group-round .segment:first-child {
    border-radius: 16px 4px 4px 16px;
}

/* Спеціальне заокруглення для останнього елемента ТІЛЬКИ в групі .connected-button-group-round */
.connected-button-group-round .segment:last-child {
    /* Згідно специфікації: 4px 16px 16px 4px */
    border-radius: 4px 16px 16px 4px;
}

  /* Активний стан та стан наведення (Hover) */
  /* Specificity (0, 2, 0). Оскільки ці правила визначені ПІСЛЯ позиційних правил,
     вони матимуть пріоритет при збігу селекторів (наприклад, для активної першої кнопки)
     і застосують повне заокруглення (морфінг). */
  .segment.active,
  .segment:hover {
    /* M3/sys/light/secondary */
    background: var(--color-secondary);
    /* Повне заокруглення при активації/наведенні */
    border-radius: 24px;
  }

  .segment.active .label,
  .segment:hover .label {
    /* M3/sys/light/on-secondary */
    color: var(--color-on-secondary);
  }
/* styles/components/buttons/_toolbar.css (M3 Update) */

  /* --- Компонент XR/XR Toolbar (Схожий на M3 Bottom App Bar) --- */

  /* XR/XR Toolbar (Основний контейнер) */
  .xr-toolbar {
    display: flex;
    flex-direction: row;
    align-items: center;
    padding: 0px;
    gap: var(--space-xs); /* Відстань між Toolbar та FAB */

    position: relative;
    /* Висота 56px як зазначено у файлі */
    height: 56px;
  }

  /* Toolbar (Внутрішній контейнер для іконок) */
  .toolbar {
    display: flex;
    flex-direction: row;
    justify-content: center;
    align-items: center;
    /* Padding 4px для центрування 48px кнопок у 56px висоті */
    padding: 8px;
    gap: 4px; /* Відстань між кнопками */

    height: 56px;

    /* M3: Surface Container */
    background: var(--color-surface-c);
    /* Повне заокруглення для стилю "пігулки" */
    border-radius: var(--radius-full);

    flex: none;
    order: 0;
    flex-grow: 0;
  }

  /* Slot (M3 Standard Icon Button) */
  .toolbar-button {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0px;

    /* Стандартний розмір M3 Icon Button (Touch Target) */
    width: 48px;
    height: 48px;
    flex: none;
    flex-grow: 0;
  }

  /* Content (Шар для фону та стану) */
  .toolbar-button .content {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0px;

    /* Внутрішній розмір (Візуальний контейнер) */
    width: 40px;
    height: 40px;
    border-radius: var(--radius-full);
    transition: background-color 0.2s ease;
  }

  /* State-layer (Використовується для центрування іконки) */
  .toolbar-button .state-layer {
    display: flex;
    justify-content: center;
    align-items: center;
    /* Центрування 24px іконки в 40px контейнері */
    padding: 8px;
    isolation: isolate;
    width: 40px;
    height: 40px;
  }

  /* Icon */
  .icon {
    width: 24px;
    height: 24px;
    transition: fill 0.2s ease;
  }

  /* Стандартний (неактивний) стан */
  .toolbar-button .icon {
    /* M3: On Surface Variant */
    fill: var(--color-on-surface-v);
  }

   /* Стан наведення (Hover) - Використовуємо State Layer (8%) */
  .toolbar-button:not(.active) .content:hover {
    /* 8% On Surface Variant overlay (колір контенту). color-mix адаптується до теми. */
    background-color: color-mix(in srgb, transparent, var(--color-on-surface-v) 8%);
  }

  /* Активний стан (M3 Filled Tonal Icon Button style) */
  .toolbar-button.active .content {
    /* M3: Secondary Container */
    background: var(--color-secondary-c);
  }

  /* Hover на активному стані */
  .toolbar-button.active .content:hover {
     /* 8% On Secondary Container overlay поверх фону Secondary Container */
    background-color: color-mix(in srgb, var(--color-secondary-c), var(--color-on-secondary-c) 8%);
  }

  .toolbar-button.active .icon {
    /* M3: On Secondary Container */
    fill: var(--color-on-secondary-c);
  }

  /* Приховані слоти */
  .toolbar-button.hidden {
      display: none;
  }

  /* FAB (Floating Action Button) - Використовуємо Accent (Tertiary) колір */
  /* Розмір Small FAB (40px) як зазначено у файлі */
  .fab {
    display: flex;
    justify-content: center;
    align-items: center;
    padding: 0px;

    width: auto;
    height: 40px;

    /* M3: Tertiary Container (Accent) */
    background: var(--color-accent-c);
    /* M3: Радіус для Small FAB (12px) */
    border-radius: var(--radius-m);
    /* M3: Elevation Level 3 */
    transition: box-shadow 0.2s ease;

    flex: none;
    order: 1;
    flex-grow: 0;
    position: relative;
    overflow: hidden; /* Для State Layer */
  }

  /* State-layer FAB (Використовується для центрування іконки) */
  .fab .state-layer {
    display: flex;
    justify-content: center;
    align-items: center;
    /* Центрує 24px іконку в 40px контейнері */
    padding: 8px;
    isolation: isolate;

    height: 40px;
  }

  /* Іконка FAB */
  .fab .icon {
    /* M3: On Tertiary Container (Accent) */
    fill: var(--color-on-accent-c);
    position: relative;
    z-index: 1;
  }

  /* FAB State Layer (::before) */
  .fab::before {
    content: "";
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    /* Колір шару такий самий як колір тексту (On Accent C) */
    background-color: var(--color-on-accent-c);
    opacity: 0;
    transition: opacity 0.2s ease;
  }

  /* FAB Hover State (Elevation 4 + State Layer 8%) */
  .fab:hover {
      /* Elevation 4 */
      box-shadow: 0px 6px 10px 4px rgba(0, 0, 0, 0.15), 0px 2px 3px 0px rgba(0, 0, 0, 0.30);
  }

  .fab:hover::before {
       opacity: 0.08;
  }
/* styles/components/lines/_checkbox.css (M3 Update - Connected Button Style) */

input[type="checkbox"] {
    /* 1. Повністю прибираємо стандартний вигляд */
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    margin: 0;
    padding: 0;
    border: none;

    /* 2. Встановлюємо розміри (24x24px, як зазначено у вашому файлі) */
    width: 24px;
    height: 24px;
    box-sizing: border-box;

    /* Допоміжні стилі */
    display: inline-flex;
    align-items: center;
    justify-content: center;
    vertical-align: middle;
    position: relative;
    cursor: pointer;

    /* 3. Стандартний (неактивний/unchecked) стан */
    /* M3: Secondary Container */
    border: 1px solid var(--color-secondary-c);
    /* Стандартне заокруглення (4px) */
    border-radius: 4px;

    /* Анімація морфінгу форми та кольору */
    transition: background-color 0.2s ease, border-radius 0.2s ease, background-image 0.2s ease;
}

/* 4. Стан наведення (Hover) та Активний стан (Checked) - Морфінг форми */

input[type="checkbox"]:checked {
    /* M3: Secondary (Темніший фон). */
    background-color: var(--color-secondary);
    /* Повне заокруглення при активації/наведенні */
    border-radius: 24px;
}

input[type="checkbox"]:hover {
    background-color: var(--color-secondary-c);
    border-radius: 24px;
}

/* 5. Іконка "галочка" (тільки для стану Checked) */
input[type="checkbox"]:checked {
    /* Додаємо "галочку". Колір: M3 On Secondary (Білий для світлої теми). */
    /* Розмір іконки 18px для 24px контейнера для кращого візуального балансу */
     background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 24 24' width='18' height='18'%3e%3cpath fill='%23FFFFFF' d='M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41L9 16.17z'/%3e%3c/svg%3e");
    background-size: 18px;
    background-position: center;
    background-repeat: no-repeat;
}

/* 6. Стан фокусу (для доступності) */
input[type="checkbox"]:focus-visible {
    /* Використовуємо Primary колір для індикатора фокусу */
    outline: 2px solid var(--color-main);
    outline-offset: 2px;
}
/* styles/components/lines/_search.css (M3 Update) */

/* Main search bar container */
.search-bar {
    display: flex;
    position: relative;
    width: 360px;
    max-width: 720px;
    height: 56px; /* Standard M3 height */
    /* M3: Background color for Search Bar is Surface Container */
    background: var(--color-surface-c);
    /* M3: Full border radius */
    border-radius: var(--radius-full);
}

/* State-layer for alignment and padding */
.search-bar .state-layer {
    display: flex;
    flex-direction: row;
    align-items: center;
    width: 100%;
    height: 100%;
    /* Padding adjusted for standard M3 layout (icons are 48x48 targets) */
    padding: 0 4px;
    box-sizing: border-box;
}

/* Hidden leading icon */
.leading-icon {
    display: none;
}

/* Content area that holds the input field */
.content {
    flex-grow: 1;
    height: 100%;
    display: flex;
    align-items: center;
    padding: 0 12px;
}

/* Styling for the search input field */
.search-input {
    width: 100%;
    height: 24px;
    border: none;
    background: transparent;
    outline: none;

    /* Font styles (M3 Body Large) */
    font-family: 'Roboto', sans-serif;
    font-style: normal;
    font-weight: 400;
    font-size: 16px;
    line-height: 24px;
    letter-spacing: 0.5px;
    /* M3: Input text color is On Surface */
    color: var(--color-on-surface);
}

/* Styling for the input's placeholder text */
.search-input::placeholder {
    /* M3: Placeholder text color is On Surface Variant */
    color: var(--color-on-surface-v);
    opacity: 1;
}

/* Container for trailing elements */
.trailing-elements {
    display: flex;
    justify-content: flex-end;
    align-items: center;

    /* Вирівнювання по правому краю всередині state-layer */
    height: 48px;
    margin-left: auto;
}

/* Styling for the search icon button (M3 Icon Button) */
.trailing-icon {
    display: flex;
    justify-content: center;
    align-items: center;
    width: 48px;
    height: 48px;

    background: none;
    border: none;
    padding: 0;
    cursor: pointer;
    border-radius: var(--radius-full);
    color: var(--color-on-surface-v);
    transition: background-color 0.2s ease;
}

/* M3 State Layer visualization on hover */
.trailing-icon:hover {
    /* 8% On Surface Variant overlay (color-mix автоматично адаптується до теми) */
    background-color: color-mix(in srgb, transparent, var(--color-on-surface-v) 8%);
}
