# Індустріальний аналіз архітектури pinguin-v5

> Event-Driven Microkernel Architecture з елементами HTML-Behavioral Attachment

Система `pinguin-v5` реалізує жорстку архітектуру, яка в індустріальних термінах класифікується як **Event-Driven Microkernel Architecture з елементами HTML-Behavioral Attachment**. Ваша відмова від монолітних фреймворків на користь модульності, де система диктує структуру коду, є класичним інженерним підходом для high-load проектів з великою кількістю legacy або незалежних команд.

Нижче наведено глибинний аналіз вашої архітектури у порівнянні з рішеннями технологічних гігантів та поточними галузевими стандартами.

---

## 1. Ядро та Плагіни (Microkernel / Plugin Architecture)

**Ваш підхід:** Ядро (`-main`, `-state`, `-core`) забезпечує оркестрацію, стан і базовий DOM. Бізнес-логіка винесена в плагіни, які не знають один про одного і вантажаться паралельно через `Promise.allSettled`.

**Як це працює в індустрії:**

* Цей патерн відомий як мікроядерна архітектура або плагінна архітектура, де ядро надає мінімальний функціонал, а сервіси реалізуються як окремі модулі.
* **Microsoft (VS Code):** Використовує архітектуру *Extension Host*. Плагіни (розширення) виконуються в повністю ізольованому середовищі (окремому процесі). Якщо плагін крашиться, UI редактора продовжує працювати без змін. Це прямий аналог вашого Закону III.
* **Figma:** Реалізує плагіни через пісочницю (Realm / QuickJS). Плагіни не мають прямого доступу до DOM і спілкуються з основним тредом лише через асинхронні повідомлення.
* **Univer (Enterprise Spreadsheet):** Використовує мікроядерну архітектуру для своїх таблиць. Ядро містить лише життєвий цикл і шину подій, а рендеринг, UI та обчислення аркушів є плагінами, що підключаються динамічно.
* **Node.js Екосистема:** Побудова плагінних систем на основі ES Modules (як у вашому `import(p)`) є стандартом для масштабованих додатків, де плагіни розв'язують основну логіку та експортують стандартний інтерфейс (як ваш `init()`).

---

## 2. Комунікація та Стан (Event-Driven State Management)

**Ваш підхід:** Плагіни не імпортують один одного. Зв'язок йде через єдине джерело правди — `state`, використовуючи хуки (`registerHook`, `runHook`).

**Як це працює в індустрії:**

* **Meta / Facebook (Flux/Redux):** Ваша ідея `state` як єдиного джерела правди повністю збігається з філософією Redux. Але Redux вимагає імутабельності (дії відправляються через *dispatch*). Ваш `runHook` є аналогом *dispatch*, але `state.data` у вас, ймовірно, мутабельний для швидкості.
* **MobX:** Бібліотека реактивного управління станом, яка відстежує залежності та автоматично оновлює дані при їх зміні. На відміну від вашого підходу з явними хуками, MobX використовує проксі для прихованої реактивності.
* **Vue.js (Event Bus / Pinia):** Ваш механізм хуків є класичним *Event Bus* (Pub/Sub). У Vue 2 це був стандарт для розв'язання зв'язків між незалежними компонентами. Сучасний підхід (Pinia) більше покладається на реактивні стори. Ваш підхід ближчий до низькорівневого паттерну `EventEmitter` у Node.js.

---

## 3. Шарми (HTML-driven / Behavioral Attachment)

**Ваш підхід:** Делегування подій на `document` у `main-core.js`, пошук елементів за атрибутами (напр., `data-clear-for`, `refresh`) для активації поведінки без написання специфічного JS для кожного компонента.

**Як це працює в індустрії:**

* Цей підхід зараз переживає ренесанс і називається "HTML-over-the-wire" або "HTML-driven JavaScript".
* **Basecamp / 37signals (Stimulus):** Мінімалістичний фреймворк, який ідеально збігається з вашими Шармами. Stimulus прив'язує логіку до HTML через атрибути `data-controller` і `data-action`. Основна відмінність: Stimulus використовує `MutationObserver` для автоматичного підхоплення нових елементів, які додаються в DOM динамічно.
* **Alpine.js:** Легковагий фреймворк для клієнтської інтерактивності, який використовує підхід на основі HTML-атрибутів (`x-data`, `x-show`, `@click`). Якщо Stimulus виносить логіку в контролери, то Alpine дозволяє писати її прямо в розмітці. Ваші шарми — це аналог глобальних директив в Alpine або контролерів у Stimulus.
* **GitHub (Catalyst):** GitHub відмовився від важких фреймворків на користь Web Components. Суть та сама: HTML віддається з сервера, а JS лише знаходить атрибути і "оживляє" їх.

---

## 4. Жорсткі Контракти Файлів

**Ваш підхід:** Один файл — одна роль (`-main`, `-state`, `-template`, `-core`). Фіксоване розмежування відповідальності. Шапка файлу містить метадані та ASCII-рамку.

**Як це працює в індустрії:**

* **Angular (Google):** Максимально близька структура. Кожен компонент примусово розбивається на `component.ts` (логіка/state), `component.html` (template), `module.ts` (оркестрація).
* **Feature-Sliced Design (FSD):** Сучасний галузевий стандарт архітектури фронтенду. Вимагає жорсткої ієрархії: шари -> слайси -> сегменти. Ваш розподіл файлів по ролях у межах однієї фічі (компонента) — це пряма імплементація сегментації FSD (де `template` — це *ui*, `state` — це *model*, а `plugin` — це *features*).

---

## 5. Вразливості системи (Bottlenecks)

Система елегантна, але при масштабуванні або збільшенні команди вона вдариться в наступні архітектурні обмеження:

### 5.1 Race Conditions хуків

Плагіни завантажуються паралельно (`Promise.allSettled`). Ви не контролюєте порядок реєстрації хуків у масиві `hooks[name]`. Якщо два плагіни підписані на `onUpdate`, і один розраховує, що інший вже відпрацював — ви отримаєте плаваючий баг. Індустрія вирішує це через систему пріоритетів при реєстрації (напр. `registerHook('onUpdate', fn, { priority: 10 })`).

### 5.2 Memory Leaks (Витоки пам'яті)

У контракті `state.js` є `registerHook`, але немає `unregisterHook`. Якщо компонент або модуль реініціалізується, хуки старих інстансів залишаться в пам'яті і будуть викликатись, що призведе до накопичення мертвих викликів.

### 5.3 Сліпота даних (Type Safety)

Оскільки плагіни "сліпі" і спілкуються через `state.data`, без жорсткої типізації (TypeScript або JSDoc) один плагін може змінити структуру об'єкта в `state`, і інший плагін впаде. `try/catch` захистить систему від крашу, але фіча просто "тихо" перестане працювати.

### 5.4 Делегування подій для Шармів

Якщо ваші Шарми покладаються лише на глобальний `document.addEventListener`, це швидко і дешево. Але якщо ви почнете динамічно додавати HTML у DOM (наприклад, після fetch-запиту), і Шарм потребує ініціалізації власного стану (як `[pagination]`), чисте делегування подій не спрацює — потрібен `MutationObserver`.
