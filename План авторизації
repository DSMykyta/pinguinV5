План міграції авторизації через Vercel (БЕЗ окремого сервера)
Як це працює на Vercel
Ваш проєкт зараз:
pinguin-v5.vercel.app
├── index.html          → Vercel роздає як статичні файли
├── entities.html       → Vercel роздає як статичні файли
├── js/...              → Vercel роздає як статичні файли
└── css/...             → Vercel роздає як статичні файли
Після міграції:
pinguin-v5.vercel.app
├── index.html          → Vercel роздає як статичні файли (як і раніше)
├── js/...              → Vercel роздає як статичні файли (як і раніше)
├── api/                → Vercel АВТОМАТИЧНО створює backend!
│   ├── auth/
│   │   ├── login.js    → стає https://pinguin-v5.vercel.app/api/auth/login
│   │   └── verify.js   → стає https://pinguin-v5.vercel.app/api/auth/verify
│   └── sheets/
│       └── proxy.js    → стає https://pinguin-v5.vercel.app/api/sheets/proxy
Магія Vercel: Коли ви кладете файл api/auth/login.js і пушите на GitHub, Vercel автоматично:
Бачить папку /api/
Створює serverless функції (mini-backend)
Робить їх доступними за URL
Вам не потрібно:
❌ Налаштовувати Node.js сервер
❌ Встановлювати Express.js
❌ Купувати хостинг
❌ Конфігурувати nginx
Vercel робить все сам!
Етап 1: Створюємо Backend Функції (через папку /api/)
Створюємо файли:
1. api/auth/login.js
Що робить: Перевіряє логін/пароль, видає JWT токен Як працює:
Користувач → POST /api/auth/login {username, password}
              ↓
         Vercel Function читає Google Sheets (аркуш Users)
              ↓
         Порівнює bcrypt.compare(password, hash)
              ↓
         Якщо OK → генерує JWT токен
              ↓
         Повертає {token, role, username}
2. api/auth/verify.js
Що робить: Перевіряє, чи валідний JWT токен Як працює:
Frontend → GET /api/auth/verify (Authorization: Bearer TOKEN)
              ↓
         Vercel Function перевіряє JWT
              ↓
         Повертає {valid: true/false, user: {...}}
3. api/sheets/proxy.js
Що робить: Проксі для Google Sheets API (приховує credentials) Як працює:
Frontend → POST /api/sheets/proxy {action: "get", range: "Sheet1!A1:Z"}
              ↓
         Vercel Function перевіряє JWT (чи залогінений користувач?)
              ↓
         Викликає Google Sheets API з вашого Service Account
              ↓
         Повертає дані → Frontend
Важливо: Google credentials зберігаються в Environment Variables на Vercel, не в коді!
Етап 2: Environment Variables на Vercel
Де налаштовувати: Vercel Dashboard → Your Project → Settings → Environment Variables Що додати:
GOOGLE_SERVICE_ACCOUNT_EMAIL=your-service@project.iam.gserviceaccount.com
GOOGLE_PRIVATE_KEY=-----BEGIN PRIVATE KEY-----\n...
SPREADSHEET_ID=1iFOCQUbisLprSfIkfCar3Oc5f8JW12kA0dpHzjEXSsk
SPREADSHEET_ID_TEXTS=1qQ2ob8zsgSfE1G64SorpdbW0xYLOdPfw_cbAH23xUhM
JWT_SECRET=випадковий_секретний_ключ_64_символи
Звідки взяти Service Account:
Google Cloud Console → Create Service Account
Дати йому доступ до ваших Google Таблиць (Share → додати email)
Завантажити JSON з ключами
Скопіювати дані в Environment Variables
Після цього: Ці дані НІКОЛИ не потрапляють в код, тільки на сервері Vercel!
Етап 3: Таблиця Користувачів (Google Sheets)
Створюємо новий аркуш "Users" у вашій таблиці:
id	username	password_hash	role	created_at	last_login
1	admin	$2b$12$...	admin	2025-11-12	2025-11-12
2	nazar	$2b$12$...	editor	2025-11-12	-
3	olena	$2b$12$...	viewer	2025-11-12	-
Як генерувати password_hash: Створюємо ще одну Vercel Function /api/auth/hash-password.js (тільки для вас):
https://pinguin-v5.vercel.app/api/auth/hash-password?pwd=мій_секретний_пароль

Повертає: $2b$12$abcdef12345... (копіюєте в таблицю)
Ролі:
admin - ви (повний доступ, бачить заборонені слова)
editor - Назар (редагує, але не бачить заборонені слова)
viewer - Олена (тільки перегляд)
Етап 4: Новий Frontend Auth (замість Google)
Що міняємо:
1. Видаляємо Google з HTML
Було в index.html, entities.html, тощо:
<script src="https://apis.google.com/js/api.js"></script>
<script src="https://accounts.google.com/gsi/client"></script>
Стає: Видаляємо ці рядки!
2. Замінюємо google-auth.js на custom-auth.js
Було:
// google-auth.js
function handleSignIn() {
    tokenClient.requestAccessToken({prompt: 'consent'});
}
Стає:
// custom-auth.js
async function handleSignIn(username, password) {
    const response = await fetch('/api/auth/login', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify({username, password})
    });
    
    const {token, role, username} = await response.json();
    localStorage.setItem('auth_token', token);
    localStorage.setItem('user_role', role);
    // Перезавантажити сторінку
}
3. UI: Форма логін/пароль
Замість кнопки "Увійти через Google":
<div id="auth-form" style="display: none;">
    <input type="text" id="login-username" placeholder="Логін">
    <input type="password" id="login-password" placeholder="Пароль">
    <button onclick="handleSignIn()">Увійти</button>
</div>
<button id="logout-btn" style="display: none;" onclick="handleSignOut()">Вийти</button>
JavaScript показує форму, якщо не залогінений:
if (!localStorage.getItem('auth_token')) {
    document.getElementById('auth-form').style.display = 'block';
} else {
    document.getElementById('logout-btn').style.display = 'block';
}
Етап 5: Проксі Google Sheets API
Що міняємо у ВСіх файлах (entities-data.js, banned-words-data.js, тощо): Було (прямий виклик):
const response = await gapi.client.sheets.spreadsheets.values.get({
    spreadsheetId: SPREADSHEET_ID, // ❌ видно в коді!
    range: 'Categories!A1:Z100'
});
const data = response.result.values;
Стає (через Vercel проксі):
const token = localStorage.getItem('auth_token');
const response = await fetch('/api/sheets/proxy', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${token}` // JWT токен
    },
    body: JSON.stringify({
        action: 'get',
        range: 'Categories!A1:Z100'
        // spreadsheetId НЕ передаємо - backend сам знає!
    })
});
const data = await response.json();
Те саме для:
values.update → {action: 'update', range: '...', values: [...]}
values.append → {action: 'append', range: '...', values: [...]}
values.batchUpdate → {action: 'batchUpdate', data: [...]}
batchUpdate (delete rows) → {action: 'batchUpdate', requests: [...]}
Етап 6: Система Ролей (UI адаптація)
Перевірка ролі у Frontend:
const userRole = localStorage.getItem('user_role');

// Приховати "Заборонені слова" від не-admin
if (userRole !== 'admin') {
    document.getElementById('aside-banned-words')?.remove();
}

// Приховати кнопки редагування від viewer
if (userRole === 'viewer') {
    document.querySelectorAll('.btn-edit, .btn-delete').forEach(btn => {
        btn.style.display = 'none';
    });
}
Перевірка на Backend (у proxy.js):
// Перевірити роль з JWT перед виконанням дії
if (action === 'update' || action === 'append' || action === 'delete') {
    if (userRole === 'viewer') {
        return res.status(403).json({error: 'Доступ заборонено'});
    }
}

// Заборонені слова тільки для admin
if (range.includes('Banned') && userRole !== 'admin') {
    return res.status(403).json({error: 'Доступ заборонено'});
}
Структура проєкту після міграції
V4 ALL ALL/
├── api/                             # НОВЕ: Vercel Functions (backend)
│   ├── auth/
│   │   ├── login.js                 # Вхід
│   │   ├── verify.js                # Перевірка токена
│   │   └── hash-password.js         # Генератор хешів (для вас)
│   └── sheets/
│       └── proxy.js                 # Проксі для Google Sheets
├── js/
│   ├── auth/
│   │   ├── google-auth.js           # ВИДАЛИТИ
│   │   └── custom-auth.js           # НОВЕ
│   ├── entities/
│   │   ├── entities-data.js         # ЗМІНИТИ: fetch замість gapi
│   │   └── ...
│   ├── banned-words/
│   │   ├── banned-words-data.js     # ЗМІНИТИ: fetch замість gapi
│   │   └── ...
│   └── main-core.js                 # ЗМІНИТИ: initAuth()
├── index.html                       # ЗМІНИТИ: форма замість Google кнопки
├── entities.html                    # ЗМІНИТИ: форма замість Google кнопки
├── banned-words.html                # ЗМІНИТИ: форма замість Google кнопки
├── glossary.html                    # ЗМІНИТИ: форма замість Google кнопки
├── vercel.json                      # НОВЕ: конфіг Vercel
└── package.json                     # НОВЕ: залежності для /api/ функцій
Deployment на Vercel
Як деплоїти:
Підключити GitHub до Vercel:
Vercel Dashboard → Import Project → Вибрати ваш GitHub репозиторій
Vercel автоматично детектує структуру
Налаштувати Environment Variables (див. Етап 2)
Push на GitHub:
git add .
git commit -m "Міграція на custom auth"
git push
Vercel автоматично:
Деплоїть статичні файли (HTML/CSS/JS)
Створює serverless функції з папки /api/
Все готово за 1-2 хвилини!
URL:
Статика: https://pinguin-v5.vercel.app/index.html
API: https://pinguin-v5.vercel.app/api/auth/login
Що зміниться для користувачів
Було:
Відкривають pinguin-v5.vercel.app
Бачать попередження Google ⚠️
Натискають "Продовжити" 2-3 рази
Дають доступ до облікового запису
Працюють
Стане:
Відкривають pinguin-v5.vercel.app
Бачать форму: [Логін] [Пароль] [Увійти]
Вводять дані (які ви їм дали)
Працюють
Ніяких вікон Google! ✅
Безпека
Що приховується від користувачів:
✅ Google Spreadsheet ID (тепер на Vercel backend)
✅ Google Service Account credentials (тепер в Environment Variables)
✅ JWT Secret (тепер в Environment Variables)
Що захищається:
✅ Паролі хешуються bcrypt на backend
✅ JWT токени з автоматичною експірацією
✅ Кожен API запит перевіряє токен
✅ Ролі перевіряються на backend (не можна обійти з frontend)
Як ви роздаватимете доступи
Варіант 1: Вручну (швидко)
Заходите в Google Таблицю → аркуш "Users"
Генеруєте хеш: відкриваєте https://pinguin-v5.vercel.app/api/auth/hash-password?pwd=пароль123
Копіюєте хеш у таблицю, додаєте username, role
Повідомляєте користувача: "Логін: nazar, Пароль: пароль123"
Варіант 2: Admin-панель (зручніше, опціонально)
Додамо сторінку /admin.html (тільки для admin)
Форма: [Username] [Password] [Role: dropdown] [Додати]
Кнопка викликає /api/auth/create-user
Все автоматично
Час реалізації
Етап 1-2: Backend functions + Environment Variables (2-3 дні)
Етап 3: Таблиця Users (0.5 дня)
Етап 4: Frontend auth (2-3 дні)
Етап 5: Проксі Google Sheets (3-4 дні)
Етап 6: Система ролей (1-2 дні)
Тестування: 1-2 дні
Загалом: 1.5-2 тижні
Важливо: ЖодногоОкремого Сервера!
Все працює на Vercel Serverless Platform:
Frontend (HTML/JS/CSS) → Vercel CDN (статичний хостинг)
Backend (файли в /api/) → Vercel Functions (автоматично)
База даних → Google Sheets (як і зараз)
Ви тільки пушите код на GitHub, Vercel робить всю магію!
